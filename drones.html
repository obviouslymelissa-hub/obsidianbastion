<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Drone Control ‚Äî Obsidian Bastion</title>
  <link rel="stylesheet" href="app.css">
  <style>
    /* Page-specific small layout helpers */
    .wrap { max-width:1200px; margin:24px auto; padding:0 18px; }
    .controls-row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .hint { color:var(--muted); font-size:0.95rem; }
    /* Wider left/right columns and larger center (makes the center "screen" bigger) */
    .grid { display:grid; grid-template-columns: 320px 1fr 320px; gap:16px; margin-top:16px; }
    .panel-card { background:var(--panel-bg, #071019); padding:14px; border-radius:8px; color:var(--text, #e6eef6); }
    .drone-list .tile { display:flex; justify-content:space-between; align-items:center; padding:10px; margin-bottom:8px; background:rgba(255,255,255,0.02); border-radius:6px; }
    .tile .meta { font-size:0.9rem; color:var(--muted); }
    /* map styles: remove fixed height to let JS manage a larger, responsive height */
    #mapCanvas { width:100%; height:64vh; background:linear-gradient(180deg,#061018, #07131a); border-radius:8px; display:block; touch-action:none; }
    .telemetry dl { display:grid; grid-template-columns: 1fr 1fr; gap:6px 18px; }
    .log { max-height:220px; overflow:auto; font-family:monospace; font-size:12px; background:rgba(0,0,0,0.12); padding:8px; border-radius:6px; color:var(--muted); }
    .btn.small { padding:6px 8px; font-size:13px; }
    #joystick { position:fixed; right:18px; bottom:18px; width:120px; height:120px; border-radius:50%; background:rgba(255,255,255,0.02); display:flex; align-items:center; justify-content:center; z-index:9999; }
    #knob { width:42px; height:42px; border-radius:50%; background:rgba(255,255,255,0.06); transition:transform 0.02s linear; }
    .camera-box { background:#000; height:140px; border-radius:6px; overflow:hidden; display:flex; align-items:center; justify-content:center; color:#999; }
    .badge { background:rgba(255,255,255,0.03); padding:6px 8px; border-radius:8px; font-weight:600; }
    .quest { display:flex; gap:8px; align-items:center; margin:6px 0; }
    @media (max-width: 980px) {
      .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <!-- Shared header (copy from other pages) -->
  <header class="site-header">
    <div class="wrap header-wrap" style="display:flex;justify-content:space-between;align-items:center;">
      <div class="header-left">
        <img src="images/StrOpBoard.png" alt="Strategic Operations Board" style="height:44px">
        <div class="header-text" aria-label="Site title">
          <h1 style="margin:0">Obsidian Bastion</h1>
          <h2 style="margin:0;font-weight:400;font-size:13px;color:var(--muted)">Drone Control</h2>
        </div>
      </div>
      <div class="header-right">
        <a href="onboardcomputer.html" class="return-command-hub" aria-label="Return to Onboard Computer">‚Üê Return</a>
      </div>
    </div>
  </header>

  <div class="wrap">
    <div class="page-header" style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
      <div>
        <h1>Launch Bay ‚Äî Drone Deck</h1>
        <div class="hint">Captain! Deploy scouts to discover points of interest, explorers to scan them, and collectors to retrieve items. Click a drone on the map to select it. Space = land, R = recall.</div>
      </div>
      <div class="controls">
        <div class="controls-row">
          <div class="badge" id="shipBadge" title="Ship">Obsidian Cruiser</div>
          <label style="display:flex;align-items:center;gap:8px"><input id="autoPilot" type="checkbox"> Auto-Launch</label>
        </div>
      </div>
    </div>

    <div class="grid" role="main" aria-label="Drone control grid">
      <!-- Left: Drone list & quick spawn -->
      <aside class="panel-card drone-list" aria-label="Drone list">
        <h3 style="margin:0 0 10px 0">Fleet</h3>
        <div id="droneList" aria-live="polite"></div>

        <div style="margin:12px 0;display:flex;justify-content:center">
          <button id="btnRecallAll" class="btn small" style="width:100%">Recall All</button>
        </div>

        <hr style="margin:12px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)">

        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <label class="hint" style="margin-right:6px">New Drone Type</label>
          <select id="newDroneType" style="padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);">
            <option value="scout">Scout</option>
            <option value="explorer">Explorer</option>
            <option value="collector">Collector</option>
            <option value="defender">Defender</option>
          </select>
          <input id="customDroneNumber" type="number" min="1" placeholder="count" style="width:80px;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);">
          <button id="btnNewDrone" class="btn small">Create Drone</button>
        </div>


      </aside>

      <!-- Center: Map / Tactical display -->
      <section class="panel-card" aria-label="Tactical map">
        <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap">
          <h3 style="margin:0 0 10px 0;flex:0 0 auto">Tactical Map</h3>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="btnToggleTrails" class="btn small">Toggle Trails</button>
          </div>
        </div>

        <canvas id="mapCanvas" width="1000" height="720" role="application" aria-label="Drone positions and paths"></canvas>
        <div style="margin-top:10px;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <div class="small" id="statusPrompt" style="color:var(--accent);font-weight:600;">Awaiting orders...</div>
          <div class="small" id="mapHint" style="margin-left:auto">Click a drone to view it. Hold Shift+Click to add a global waypoint for all drones.</div>
        </div>
      </section>

      <!-- Right: Telemetry, camera & logs -->
      <aside class="panel-card telemetry" aria-label="Telemetry and logs">
        <h3 style="margin:0 0 10px 0">Telemetry</h3>
        <div id="selectedDroneName" style="font-weight:700">‚Äî</div>
        <dl style="margin-top:8px">
          <div style="display:flex;justify-content:space-between"><div class="meta">Type</div><div id="sel_type" class="meta">‚Äî</div></div>
          <div style="display:flex;justify-content:space-between"><div class="meta">Status</div><div id="sel_status" class="meta">‚Äî</div></div>
          <div style="display:flex;justify-content:space-between"><div class="meta">Battery</div><div id="sel_batt" class="meta">‚Äî</div></div>
          <div style="display:flex;justify-content:space-between"><div class="meta">Altitude</div><div id="sel_alt" class="meta">‚Äî</div></div>
          <div style="display:flex;justify-content:space-between"><div class="meta">Speed</div><div id="sel_spd" class="meta">‚Äî</div></div>
        </dl>

        <hr style="margin:10px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)">
        
        <div id="scoutActionButtons" style="display:none;gap:8px;margin-bottom:8px;flex-direction:column;">
          <button id="btnReturnToBase" class="btn small">Return to Base</button>
          <button id="btnContinueExploring" class="btn small">Continue Exploring</button>
        </div>

        <div style="margin-bottom:8px">
          <div class="small">Camera</div>
          <div class="camera-box" id="cameraBox"><canvas id="camCanvas" width="280" height="140" style="width:100%;height:100%"></canvas></div>
        </div>

        <div class="small" style="margin-bottom:6px">Activity Log</div>
        <div id="log" class="log" aria-live="polite">No activity</div>
      </aside>
    </div>
  </div>

  <div id="joystick" title="Joystick (touch/mouse)">
    <div id="knob"></div>
  </div>

  <footer style="text-align:center;color:var(--muted);padding:24px 0 40px;border-top:1px solid rgba(255,255,255,0.03);margin-top:18px;font-style:italic;">
    <div style="margin-bottom:12px">
      <a href="index.html" style="color:var(--accent);text-decoration:none;font-weight:600">Vessel Profile</a>
    </div>
    &copy; 2026 - Turning Imagination Into Galactic Frontiers.
  </footer>

  <script>
  (function(){
    /* Simpler kid-friendly drone deck:
       - Removed mission editor UI
       - Added explicit "Assign to Fleet" buttons for quests
       - Left core behaviors: spawn, launch, waypoints, quests, intruders
    */

    // Elements
    const el = {
      droneList: document.getElementById('droneList'),
      mapCanvas: document.getElementById('mapCanvas'),
      selectedName: document.getElementById('selectedDroneName'),
      sel_type: document.getElementById('sel_type'),
      sel_status: document.getElementById('sel_status'),
      sel_batt: document.getElementById('sel_batt'),
      sel_alt: document.getElementById('sel_alt'),
      sel_spd: document.getElementById('sel_spd'),
      log: document.getElementById('log'),
      btnNewDrone: document.getElementById('btnNewDrone'),
      btnToggleTrails: document.getElementById('btnToggleTrails'),
      btnRecallAll: document.getElementById('btnRecallAll'),
      newDroneType: document.getElementById('newDroneType'),
      customDroneNumber: document.getElementById('customDroneNumber'),
      autoPilot: document.getElementById('autoPilot'),
      camCanvas: document.getElementById('camCanvas'),
      joystick: document.getElementById('joystick'),
      knob: document.getElementById('knob'),
      statusPrompt: document.getElementById('statusPrompt'),
      scoutActionButtons: document.getElementById('scoutActionButtons'),
      btnReturnToBase: document.getElementById('btnReturnToBase'),
      btnContinueExploring: document.getElementById('btnContinueExploring')
    };

    const ctx = el.mapCanvas.getContext('2d');
    const camCtx = el.camCanvas.getContext('2d');

    // Constants
    const COLLECT_TIMEOUT_MS = 120000; // 2 minutes
    const RING_BASE_OPACITY = 0.08;
    const RING_MIN_OPACITY = 0.01;
    const STORAGE_KEY_COLLECTED = 'drones:collected:v1';
    const DISCOVERY_COOLDOWN = 10000; // 10 seconds between discoveries
    const SCOUT_DISCOVERY_PROBABILITY = 0.003; // Higher probability per frame to find things more often
    const SCOUT_PATROL_DURATION = 45000; // 45 seconds of scouting
    const RETURN_STOP_THRESHOLD = 30; // Distance to stop when returning to base
    const DEFAULT_STOP_THRESHOLD = 10; // Default waypoint arrival distance
    const MAX_POIS_ON_SCREEN = 10; // Maximum POIs before scout finishes (changed from 4 to 10)
    const SCOUT_WAYPOINT_DISTANCE = 200; // Distance between scout patrol waypoints (increased from 150 to avoid circling)
    const EXPLORER_DISCOVERY_PROBABILITY = 0.4; // 40% chance for explorer to find items (increased from 0.001)
    const DEFENDER_LOW_BATTERY_THRESHOLD = 40; // Defender returns to base when battery drops to this level

    // Simulation state
    let drones = []; // {id,name,type,x,y,vx,vy,alt,battery,status,waypoints,followers,collectTarget,collectStartTime,collectTimeoutId}
    let selected = null;
    let showPaths = true;
    let trailsEnabled = true;
    let trails = {};
    let intruders = [];
    let pointsOfInterest = []; // {id,x,y,type,scanned,name,items,discoveredBy}
    let collectedItems = loadCollectedItems();
    let mapSize = { w: el.mapCanvas.clientWidth, h: el.mapCanvas.clientHeight };
    
    // Helper to get primary drone of a specific type
    function getPrimaryDrone(type) {
      return drones.find(d => d.type === type && d.isPrimary);
    }

    function generateId(){ return 'd-'+Math.random().toString(36).slice(2,9); }
    function now(){ return Date.now(); }
    function log(msg){
      const ts = new Date().toLocaleTimeString();
      const line = `[${ts}] ${msg}`;
      const cur = el.log.textContent.trim();
      el.log.textContent = (cur === 'No activity' ? '' : cur + '\n') + line;
      el.log.scrollTop = el.log.scrollHeight;
      console.log(line);
    }
    function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function updateStatusPrompt(msg){
      if(el.statusPrompt){
        el.statusPrompt.textContent = msg;
      }
    }
    
    // Generate scout patrol waypoints
    function generateScoutPatrolWaypoints(drone, count = 3){
      for(let i = 0; i < count; i++){
        const angle = Math.random() * Math.PI * 2;
        const distance = SCOUT_WAYPOINT_DISTANCE + Math.random() * 150; // Increased variation
        const wx = clamp(drone.x + Math.cos(angle) * distance, 40, mapSize.w - 40);
        const wy = clamp(drone.y + Math.sin(angle) * distance, 40, mapSize.h - 40);
        drone.waypoints.push({ x: wx, y: wy, id: generateId() });
      }
    }

    // Helper: remove waypoints that reference a poiId
    function removeWaypointsForPoi(poiId){
      if(!poiId) return;
      drones.forEach(d => {
        if(d.waypoints && d.waypoints.length){
          const before = d.waypoints.length;
          d.waypoints = d.waypoints.filter(w => w.poiId !== poiId);
          if(d.waypoints.length !== before){
            // nothing else required here ‚Äî drones will pick new targets naturally
          }
        }
      });
    }

    // Helper: remove any waypoints near coordinates (safety for older waypoints without poiId)
    function removeWaypointsNear(x,y,radius = 18){
      drones.forEach(d => {
        if(d.waypoints && d.waypoints.length){
          d.waypoints = d.waypoints.filter(w => {
            const dx = w.x - x;
            const dy = w.y - y;
            return Math.hypot(dx,dy) > radius;
          });
        }
      });
    }

    // Load/save collected items
    function loadCollectedItems(){
      try {
        const raw = localStorage.getItem(STORAGE_KEY_COLLECTED);
        return raw ? JSON.parse(raw) : [];
      } catch(e){
        return [];
      }
    }
    function saveCollectedItems(){
      try {
        localStorage.setItem(STORAGE_KEY_COLLECTED, JSON.stringify(collectedItems));
      } catch(e){
        console.error('Failed to save collected items:', e);
      }
    }

    // Generate random points of interest types
    function generatePOI(){
      const types = ['asteroid', 'moon fragment', 'planet debris', 'space junk', 'derelict probe', 'crystal formation', 'alien flora', 'mineral deposit', 'ancient wreckage'];
      const type = types[Math.floor(Math.random() * types.length)];
      const x = Math.random() * (mapSize.w - 80) + 40;
      const y = Math.random() * (mapSize.h - 80) + 40;
      return {
        id: 'poi-' + generateId(),
        x, y,
        type,
        scanned: false,
        name: null,
        items: null,
        discoveredBy: null
      };
    }

    // Generate items for a scanned POI
    function generateItems(poiType){
      const itemPool = {
        'asteroid': [
          { name: 'Rare Mineral Sample', mundane: false },
          { name: 'Iron Ore', mundane: true },
          { name: 'Crystalline Fragment', mundane: false },
          { name: 'Titanium Ore', mundane: true },
          { name: 'Platinum Deposit', mundane: false }
        ],
        'moon fragment': [
          { name: 'Ancient Moon Rock', mundane: false },
          { name: 'Sensor Module', mundane: true },
          { name: 'Lunar Ice Sample', mundane: false },
          { name: 'Solar Panel', mundane: true },
          { name: 'Battery', mundane: true }
        ],
        'planet debris': [
          { name: 'Atmospheric Analyzer', mundane: true },
          { name: 'Alien Artifact', mundane: false },
          { name: 'Power Cell', mundane: true },
          { name: 'Oxygen Filter', mundane: true },
          { name: 'Engine Component', mundane: true }
        ],
        'space junk': [
          { name: 'Hull Plate', mundane: true },
          { name: 'Antenna', mundane: true },
          { name: 'Navigation Computer Fragment', mundane: false },
          { name: 'Thruster', mundane: true },
          { name: 'Coolant Pump', mundane: true }
        ],
        'derelict probe': [
          { name: 'Data Core', mundane: false },
          { name: 'Thruster Component', mundane: true },
          { name: 'Communication Array', mundane: true },
          { name: 'Navigation Computer', mundane: true },
          { name: 'Sensor Module', mundane: true },
          { name: 'Engine', mundane: true }
        ],
        'crystal formation': [
          { name: 'Energy Crystal', mundane: false },
          { name: 'Quantum Resonator', mundane: false },
          { name: 'Coolant Pump', mundane: true },
          { name: 'Kyber Crystal', mundane: false },
          { name: 'Dilithium Shard', mundane: false }
        ],
        'alien flora': [
          { name: 'Bioluminescent Plant', mundane: false },
          { name: 'Medicinal Herb', mundane: false },
          { name: 'Alien Spore Sample', mundane: false },
          { name: 'Oxygen-Producing Algae', mundane: false },
          { name: 'Exotic Fungus', mundane: false }
        ],
        'mineral deposit': [
          { name: 'Copper Ore', mundane: true },
          { name: 'Gold Nugget', mundane: false },
          { name: 'Rare Earth Metals', mundane: false },
          { name: 'Uranium Sample', mundane: false },
          { name: 'Diamond', mundane: false }
        ],
        'ancient wreckage': [
          { name: 'Ancient Technology', mundane: false },
          { name: 'Hull Plate', mundane: true },
          { name: 'Power Cell', mundane: true },
          { name: 'Engine', mundane: true },
          { name: 'Alien Relic', mundane: false },
          { name: 'Thruster', mundane: true }
        ]
      };
      const pool = itemPool[poiType] || itemPool['space junk'];
      const numItems = 1 + Math.floor(Math.random() * 2); // 1-2 items
      const items = [];
      for(let i = 0; i < numItems; i++){
        const item = pool[Math.floor(Math.random() * pool.length)];
        items.push({ ...item });
      }
      return items;
    }

    // Add item to research log
    function addToResearch(itemName, description){
      try {
        const RESEARCH_KEY = 'research:items:v1';
        const raw = localStorage.getItem(RESEARCH_KEY);
        const items = raw ? JSON.parse(raw) : [];
        
        // Check if item already exists
        if(items.find(i => i.name === itemName)){
          return; // Don't add duplicates
        }
        
        const newItem = {
          id: 'r-' + Date.now() + '-' + Math.random().toString(36).slice(2, 9),
          name: itemName,
          description: description,
          status: 'not-started',
          createdAt: Date.now(),
          updatedAt: Date.now()
        };
        items.push(newItem);
        localStorage.setItem(RESEARCH_KEY, JSON.stringify(items));
        log(`Added ${itemName} to Research Lab`);
      } catch(e){
        console.error('Failed to add to research:', e);
      }
    }

    // Add item to parts inventory
    function addToPartsInventory(itemName){
      try {
        const INVENTORY_KEY = 'ship.inventory.v1';
        const raw = localStorage.getItem(INVENTORY_KEY);
        const inventory = raw ? JSON.parse(raw) : {};
        
        // Normalize item name to match inventory keys
        const key = itemName.toLowerCase();
        if(inventory[key] == null) inventory[key] = 0;
        inventory[key] += 1;
        
        localStorage.setItem(INVENTORY_KEY, JSON.stringify(inventory));
        log(`Added ${itemName} to Parts Inventory`);
      } catch(e){
        console.error('Failed to add to inventory:', e);
      }
    }

    // Canvas resize
    function resizeMapCanvas(){
      const DPR = window.devicePixelRatio || 1;
      const cw = el.mapCanvas.clientWidth;
      const ch = el.mapCanvas.clientHeight;
      el.mapCanvas.width = Math.max(320, Math.round(cw * DPR));
      el.mapCanvas.height = Math.max(240, Math.round(ch * DPR));
      ctx.setTransform(DPR,0,0,DPR,0,0);
      mapSize.w = cw;
      mapSize.h = ch;
      drones.forEach(d => {
        d.x = clamp(d.x, 6, mapSize.w-6);
        d.y = clamp(d.y, 6, mapSize.h-6);
      });
    }
    window.addEventListener('resize', resizeMapCanvas);

    // Create drone (with type)
    function addDrone(name, type){
      if(!mapSize.w || !mapSize.h) resizeMapCanvas();
      
      // If no name is provided, check if a primary drone of this type already exists
      if(!name){
        const primary = getPrimaryDrone(type);
        if(primary) {
          // This is a follower drone - increment the follower count
          primary.followers = (primary.followers || 0) + 1;
          log(`Added follower to ${primary.name} (now ${primary.followers} followers)`);
          renderList();
          return primary;
        }
      }
      
      // Create a new primary drone - START AT CENTER (docked at Obsidian)
      const d = {
        id: generateId(),
        name: name || (type.charAt(0).toUpperCase()+type.slice(1) + '-01'),
        type: type || 'explorer',
        isPrimary: true,
        followers: 0,
        x: mapSize.w/2,
        y: mapSize.h/2,
        vx: 0, vy: 0,
        targetVx: 0, targetVy: 0,
        alt: 0,
        battery: 70 + Math.floor(Math.random()*30),
        status: 'docked',
        waypoints: [],
        lastUpdate: now(),
        taskCompleted: false,
        lastDiscoveryTime: 0
      };
      drones.push(d);
      trails[d.id] = [];
      log(`Created ${d.name} (${d.type})`);
      renderList();
      if(el.autoPilot.checked){
        launchDrone(d.id);
      }
      return d;
    }

    // List UI
    function renderList(){
      el.droneList.innerHTML = '';
      // Sort drones by type order: scout, explorer, collector, defender
      const typeOrder = { 'scout': 1, 'explorer': 2, 'collector': 3, 'defender': 4 };
      const sortedDrones = drones.slice().sort((a, b) => {
        const orderA = typeOrder[a.type] || 999;
        const orderB = typeOrder[b.type] || 999;
        return orderA - orderB;
      });
      
      sortedDrones.forEach(d => {
        const tile = document.createElement('div');
        tile.className = 'tile';
        const followerText = d.followers > 0 ? ` (${d.followers} follower${d.followers !== 1 ? 's' : ''})` : '';
        
        // Determine status display with proper charging/docked logic
        let displayStatus = d.status;
        let statusIndicator = '';
        if(d.status === 'docked' || d.status === 'idle'){
          if(d.battery >= 100){
            displayStatus = 'idle';
            statusIndicator = '‚ö™'; // White circle for docked/idle
          } else {
            displayStatus = 'charging';
            statusIndicator = 'üîã'; // Battery icon for charging
          }
        } else if(d.status === 'flying' || d.status === 'returning'){
          displayStatus = d.status === 'flying' ? 'active' : 'returning';
          statusIndicator = 'üü¢'; // Green circle for active
        } else {
          statusIndicator = '‚ö™';
        }
        
        tile.innerHTML = `
          <div>
            <div style="font-weight:700">${statusIndicator} ${d.name}${followerText}</div>
            <div class="meta">${d.type} ‚Ä¢ ${displayStatus} ‚Ä¢ ${Math.round(d.battery)}%</div>
          </div>
          <div style="display:flex;gap:6px;align-items:center">
            <button class="btn small" data-action="select" data-id="${d.id}">Select</button>
            <button class="btn small" data-action="launch" data-id="${d.id}">Launch</button>
            <button class="btn small" data-action="recall" data-id="${d.id}">Recall</button>
          </div>
        `;
        el.droneList.appendChild(tile);
      });
    }

    function selectDrone(id){
      selected = drones.find(x => x.id === id) || null;
      if(selected){
        el.selectedName.textContent = `${selected.name} ‚Äî ${selected.id}`;
        el.sel_type.textContent = selected.type;
        
        // Determine status display with proper charging/docked logic
        let displayStatus = selected.status;
        if(selected.status === 'docked' || selected.status === 'idle'){
          if(selected.battery >= 100){
            displayStatus = 'idle';
          } else {
            displayStatus = 'charging';
          }
        } else if(selected.status === 'flying'){
          displayStatus = 'active';
        }
        
        el.sel_status.textContent = displayStatus;
        el.sel_batt.textContent = Math.round(selected.battery) + '%';
        el.sel_alt.textContent = Math.round(selected.alt) + ' m';
        el.sel_spd.textContent = (Math.hypot(selected.vx, selected.vy)).toFixed(1) + ' m/s';
        
        // Show scout action buttons if scout completed without finding anything
        const isScoutWithNoFinds = selected.type === 'scout' && selected.taskCompleted && (selected.poiDiscoveryCount || 0) === 0;
        if(el.scoutActionButtons && isScoutWithNoFinds){
          el.scoutActionButtons.style.display = 'flex';
        } else if(el.scoutActionButtons){
          el.scoutActionButtons.style.display = 'none';
        }
      } else {
        el.selectedName.textContent = '‚Äî';
        el.sel_type.textContent = '‚Äî';
        el.sel_status.textContent = '‚Äî';
        el.sel_batt.textContent = '‚Äî';
        el.sel_alt.textContent = '‚Äî';
        el.sel_spd.textContent = '‚Äî';
        if(el.scoutActionButtons){
          el.scoutActionButtons.style.display = 'none';
        }
      }
      renderMap();
    }

    // Commands
    function launchDrone(id){
      const d = drones.find(x => x.id === id);
      if(!d) return;
      
      // Check if collector has any items to collect
      if(d.type === 'collector'){
        const ready = pointsOfInterest.filter(p => p.scanned && p.items && p.items.length > 0);
        if(ready.length === 0){
          updateStatusPrompt('Awaiting collection orders - no items available');
          log(`${d.name} awaiting collection orders - no items to collect`);
          return; // Don't launch if there's nothing to collect
        }
      }
      
      d.status = 'flying';
      d.alt = Math.max(d.alt, 30);
      d.taskCompleted = false;
      d.lastDiscoveryTime = now(); // Initialize discovery time when launching
      d.launchTime = now(); // Track when drone was launched
      d.poiDiscoveryCount = 0; // Track how many POIs discovered this session
      
      // Scout: Set up initial patrol waypoints
      if(d.type === 'scout'){
        d.waypoints = [];
        // Generate initial patrol waypoints
        generateScoutPatrolWaypoints(d, 3);
      }
      
      // Defender: Set up orbital waypoints around the ship
      if(d.type === 'defender'){
        d.waypoints = [];
        const orbitRadius = Math.min(mapSize.w, mapSize.h) * 0.15;
        const orbitPoints = 8;
        for(let i = 0; i < orbitPoints; i++){
          const angle = (i / orbitPoints) * Math.PI * 2;
          d.waypoints.push({
            x: mapSize.w/2 + Math.cos(angle) * orbitRadius,
            y: mapSize.h/2 + Math.sin(angle) * orbitRadius,
            id: generateId()
          });
        }
        // Make it loop by adding the first point at the end
        d.waypoints.push({
          x: d.waypoints[0].x,
          y: d.waypoints[0].y,
          id: generateId()
        });
        d.isOrbiting = true; // Flag to indicate defender is in orbital mode
      }

      // Collector: immediately assign waypoints to scanned POIs with items (nearest-first)
      if(d.type === 'collector'){
        const ready = pointsOfInterest.filter(p => p.scanned && p.items && p.items.length > 0);
        // sort by distance to the collector
        ready.sort((a,b) => {
          const da = Math.hypot(a.x - d.x, a.y - d.y);
          const db = Math.hypot(b.x - d.x, b.y - d.y);
          return da - db;
        });
        d.waypoints = ready.map(p => ({ x: p.x, y: p.y, id: generateId(), poiId: p.id }));
        if(d.waypoints.length > 0){
          log(`${d.name} launched and assigned to ${d.waypoints.length} collect target(s)`);
        }
      }
      
      const speedBase = d.type === 'scout' ? 2.2 : (d.type === 'defender' ? 1.2 : 1.0);
      d.targetVx = (Math.random()-0.5) * speedBase;
      d.targetVy = (Math.random()-0.5) * speedBase;
      log(`Launched ${d.name}`);
      
      // Hide scout action buttons when launching
      if(el.scoutActionButtons && d.type === 'scout'){
        el.scoutActionButtons.style.display = 'none';
      }
      
      // Update status prompt based on drone type
      if(d.type === 'scout'){
        updateStatusPrompt('Scouting...');
      } else if(d.type === 'explorer'){
        updateStatusPrompt('Exploring...');
      } else if(d.type === 'collector'){
        updateStatusPrompt('Collecting...');
      } else if(d.type === 'defender'){
        updateStatusPrompt('Defender in orbit...');
      }
      
      renderList();
    }
    function landDrone(id){
      const d = drones.find(x => x.id === id);
      if(!d) return;
      d.status = 'landing';
      d.targetVx = 0; d.targetVy = 0;
      log(`Landing ${d.name}`);
      setTimeout(() => {
        d.status = 'idle';
        d.alt = 0;
        renderList();
      }, 1200);
    }
    function recallDrone(id){
      const d = drones.find(x => x.id === id);
      if(!d) return;
      d.status = 'returning';
      d.taskCompleted = false;
      d.isOrbiting = false; // Stop orbital mode if defender
      d.waypoints = [{ x: mapSize.w/2, y: mapSize.h/2 }];
      log(`Recalling ${d.name}`);
      updateStatusPrompt(`${d.name} returning to base...`);
    }
    function recallAllDrones(){
      drones.forEach(d => {
        d.status = 'returning';
        d.taskCompleted = false;
        d.isOrbiting = false; // Stop orbital mode for all defenders
        d.waypoints = [{ x: mapSize.w/2, y: mapSize.h/2 }];
      });
      log(`Recalling all drones to center`);
      updateStatusPrompt('All drones returning to base...');
    }
    function abortDrone(id){
      const d = drones.find(x => x.id === id);
      if(!d) return;
      d.status = 'idle';
      d.targetVx = 0; d.targetVy = 0; d.waypoints = [];
      // Clear any collection timeout
      if(d.collectTimeoutId){
        clearTimeout(d.collectTimeoutId);
        d.collectTimeoutId = null;
      }
      log(`${d.name} aborted`);
      renderList();
    }

    // Waypoints
    function addWaypointToSelected(x,y){
      if(!selected) { alert('Select a drone first'); return; }
      selected.waypoints.push({ x, y, id: generateId() });
      log(`Waypoint added to ${selected.name} (${Math.round(x)},${Math.round(y)})`);
    }

    // Spawn a wave of N drones of selected type
    function spawnWave(count = 6){
      const type = el.newDroneType.value || 'explorer';
      for(let i=0;i<count;i++){
        const d = addDrone(`${type.charAt(0).toUpperCase()+type.slice(1)} ${drones.length+1}`, type);
        if(!d.isPrimary) continue; // Skip if it was added as a follower
        if(type === 'explorer'){
          d.waypoints = [{ x: Math.random()*(mapSize.w-80)+40, y: Math.random()*(mapSize.h-80)+40, id: generateId() }];
        } else if(type === 'defender'){
          const a = (i/count) * Math.PI*2;
          const r = Math.min(mapSize.w,mapSize.h)*0.2;
          d.waypoints = [{ x: mapSize.w/2 + Math.cos(a)*r, y: mapSize.h/2 + Math.sin(a)*r, id: generateId() }];
        } else if(type === 'scout'){
          // Add multiple waypoints for scouts to patrol
          const n = 8;
          for(let j=0;j<n;j++){
            d.waypoints.push({ x: Math.random()*(mapSize.w-80)+40, y: Math.random()*(mapSize.h-80)+40, id: generateId() });
          }
        } else if(type === 'collector'){
          d.waypoints = [{ x: Math.random()*(mapSize.w-80)+40, y: Math.random()*(mapSize.h-80)+40, id: generateId() }];
        }
        if(el.autoPilot.checked) launchDrone(d.id);
      }
      log(`Spawned wave of ${count} ${el.newDroneType.value}s`);
    }

    // Intruders spawn occasionally for defenders
    function spawnIntruder(){
      const x = Math.random()*(mapSize.w-40)+20;
      const y = Math.random()*(mapSize.h-40)+20;
      const id = 'intr-'+Math.random().toString(36).slice(2,8);
      intruders.push({ id, x, y, ttl: 8000 });
      log(`Intruder detected!`);
    }

    // Trails management
    function pushTrail(d){
      const t = trails[d.id] || (trails[d.id]=[]);
      t.push({ x:d.x, y:d.y, ttl: 2000 + Math.random()*800 });
      if(t.length > 200) t.shift();
    }
    function updateTrails(dt){
      Object.keys(trails).forEach(id => {
        const arr = trails[id];
        for(let i = arr.length-1; i >= 0; --i){
          arr[i].ttl -= dt;
          if(arr[i].ttl <= 0) arr.splice(i,1);
        }
      });
    }

    // Render
    function renderMap(){
      const c = ctx;
      c.clearRect(0,0,mapSize.w,mapSize.h);
      c.fillStyle = '#041217';
      c.fillRect(0,0,mapSize.w,mapSize.h);

      // Draw concentric rings around the ship for distance reference
      const centerX = mapSize.w/2;
      const centerY = mapSize.h/2;
      const maxRadius = Math.min(mapSize.w, mapSize.h) / 2;
      const ringCount = 5;
      
      for(let i = 1; i <= ringCount; i++){
        const radius = (maxRadius / ringCount) * i;
        c.beginPath();
        c.strokeStyle = `rgba(79, 209, 197, ${Math.max(RING_MIN_OPACITY, RING_BASE_OPACITY - (i * 0.01))})`;
        c.lineWidth = 1;
        c.arc(centerX, centerY, radius, 0, Math.PI * 2);
        c.stroke();
      }

      // ship in center
      c.fillStyle = '#0f4f6f';
      c.beginPath();
      c.arc(mapSize.w/2, mapSize.h/2, 26, 0, Math.PI*2);
      c.fill();
      c.fillStyle = '#fff';
      c.font = '12px system-ui';
      c.fillText('OBSIDIAN', mapSize.w/2 - 28, mapSize.h/2 + 4);

      // intruders
      intruders.forEach(i => {
        c.beginPath();
        c.fillStyle = 'rgba(255,80,80,0.95)';
        c.arc(i.x, i.y, 8, 0, Math.PI*2);
        c.fill();
      });

      // points of interest
      pointsOfInterest.forEach(poi => {
        // Only render POIs that have items or are unscanned
        c.beginPath();
        if(poi.scanned){
          // Scanned POIs with items
          c.fillStyle = poi.items && poi.items.length ? 'rgba(79,209,197,0.6)' : 'rgba(100,100,100,0.4)';
          c.strokeStyle = 'rgba(79,209,197,0.8)';
        } else {
          // Unscanned POIs discovered by scouts
          c.fillStyle = 'rgba(255,200,80,0.5)';
          c.strokeStyle = 'rgba(255,200,80,0.8)';
        }
        c.lineWidth = 2;
        c.arc(poi.x, poi.y, 10, 0, Math.PI*2);
        c.fill();
        c.stroke();
        
        // Draw icon based on type
        c.fillStyle = '#fff';
        c.font = 'bold 14px system-ui';
        const icon = poi.scanned ? '‚úì' : '?';
        c.fillText(icon, poi.x - 5, poi.y + 5);
        
        // Draw "Object Found" label for unscanned POIs discovered by scouts
        if(!poi.scanned && poi.discoveredBy){
          c.fillStyle = 'rgba(255,255,255,0.7)';
          c.font = '10px system-ui';
          c.fillText('Object Found', poi.x - 24, poi.y - 15);
        }
      });

      // trails
      if(trailsEnabled){
        Object.values(trails).forEach(arr => {
          for(let i=1;i<arr.length;i++){
            const a = arr[i-1], b = arr[i];
            c.beginPath();
            c.strokeStyle = `rgba(155,231,198,${0.06 + ((b.ttl||1000)/3000)})`;
            c.lineWidth = 2;
            c.moveTo(a.x,a.y); c.lineTo(b.x,b.y); c.stroke();
          }
        });
      }

      // paths and waypoints
      if(showPaths){
        drones.forEach(d => {
          if(d.waypoints && d.waypoints.length){
            c.beginPath();
            c.strokeStyle = 'rgba(255,180,130,0.18)';
            c.lineWidth = 1.2;
            c.moveTo(d.x,d.y);
            d.waypoints.forEach(w => c.lineTo(w.x,w.y));
            c.stroke();

            d.waypoints.forEach(w => {
              c.beginPath();
              c.fillStyle = '#ffb482';
              c.arc(w.x, w.y, 6, 0, Math.PI*2);
              c.fill();
            });
          }
        });
      }

      // drones
      drones.forEach(d => {
        c.beginPath();
        const isSel = selected && selected.id === d.id;
        const color = d.type === 'defender' ? '#ffd47a' : (d.type === 'scout' ? '#7ad1ff' : (d.type === 'collector' ? '#d47aff' : '#9be7c6'));
        c.fillStyle = isSel ? '#fff8dc' : color;
        c.strokeStyle = isSel ? '#ffb84d' : '#03181b';
        c.lineWidth = isSel ? 2 : 1;
        c.arc(d.x, d.y, isSel ? 10 : 7, 0, Math.PI*2);
        c.fill();
        c.stroke();

        c.fillStyle = 'rgba(255,255,255,0.85)';
        c.font = '12px system-ui';
        const followerText = d.followers > 0 ? ` (${d.followers})` : '';
        c.fillText(d.name + followerText, d.x + 12, d.y + 5);
      });
    }

    // Physics / behaviors
    let lastFrame = now();
    function step(){
      const t = now();
      const dt = t - lastFrame;
      lastFrame = t;

      // intruder TTL
      for(let i = intruders.length-1; i >= 0; --i){
        intruders[i].ttl -= dt;
        if(intruders[i].ttl <= 0) intruders.splice(i,1);
      }

      const currentIntruder = intruders.length ? intruders[0] : null;

      drones.forEach(d => {
        // Defender low battery check - return to base if battery is critically low
        if(d.type === 'defender' && d.isOrbiting && d.battery <= DEFENDER_LOW_BATTERY_THRESHOLD && d.status !== 'returning'){
          log(`${d.name} battery critical (${Math.round(d.battery)}%) - returning to base`);
          d.status = 'returning';
          d.isOrbiting = false;
          d.waypoints = [{ x: mapSize.w/2, y: mapSize.h/2, id: generateId() }];
          updateStatusPrompt(`${d.name} low battery - returning to base`);
        }
        
        if(d.type === 'defender' && currentIntruder){
          const dx = currentIntruder.x - d.x, dy = currentIntruder.y - d.y;
          const dist = Math.hypot(dx,dy);
          if(dist > 14){
            d.waypoints.unshift({ x: currentIntruder.x + (Math.random()-0.5)*6, y: currentIntruder.y + (Math.random()-0.5)*6, id: generateId() });
            if(d.waypoints.length > 6) d.waypoints.length = 6;
            d.status = 'flying';
            d.isOrbiting = false; // Stop orbit to intercept
          } else {
            if(currentIntruder){
              log(`${d.name} intercepted an intruder!`);
              intruders.splice(0,1);
              // Resume orbit after interception
              if(d.type === 'defender' && d.battery > DEFENDER_LOW_BATTERY_THRESHOLD){
                const orbitRadius = Math.min(mapSize.w, mapSize.h) * 0.15;
                const orbitPoints = 8;
                d.waypoints = [];
                for(let i = 0; i < orbitPoints; i++){
                  const angle = (i / orbitPoints) * Math.PI * 2;
                  d.waypoints.push({
                    x: mapSize.w/2 + Math.cos(angle) * orbitRadius,
                    y: mapSize.h/2 + Math.sin(angle) * orbitRadius,
                    id: generateId()
                  });
                }
                d.isOrbiting = true;
              }
            }
          }
        }

        // Scout: Check for nearby POIs to discover - only one at a time, limit to max
        if(d.type === 'scout' && !d.taskCompleted && d.status === 'flying'){
          const timeSinceLastDiscovery = t - (d.lastDiscoveryTime || 0);
          const currentPOICount = pointsOfInterest.length;
          
          // Only discover if we have less than max POIs and cooldown passed
          if(currentPOICount < MAX_POIS_ON_SCREEN && timeSinceLastDiscovery > DISCOVERY_COOLDOWN && Math.random() < SCOUT_DISCOVERY_PROBABILITY){
            const newPOI = generatePOI();
            // Place POI near the scout
            newPOI.x = clamp(d.x + (Math.random() - 0.5) * 60, 40, mapSize.w - 40);
            newPOI.y = clamp(d.y + (Math.random() - 0.5) * 60, 40, mapSize.h - 40);
            newPOI.discoveredBy = d.name;
            pointsOfInterest.push(newPOI);
            d.lastDiscoveryTime = t;
            d.poiDiscoveryCount = (d.poiDiscoveryCount || 0) + 1;
            log(`${d.name} discovered ${newPOI.type} at (${Math.round(newPOI.x)},${Math.round(newPOI.y)})`);
            updateStatusPrompt('Unidentified object located');
            
            // If reached max POIs, mark as completed
            if(currentPOICount + 1 >= MAX_POIS_ON_SCREEN){
              d.taskCompleted = true;
              d.waypoints = [];
              log(`${d.name} scouting complete - maximum objects found`);
              updateStatusPrompt('Scouting complete - max objects found');
              // Automatically return to base
              d.status = 'returning';
              d.waypoints = [{ x: mapSize.w/2, y: mapSize.h/2, id: generateId() }];
              log(`${d.name} returning to base`);
            }
          }
          
          // Generate new waypoint when reaching current one to keep moving
          // Ensure waypoints are at least SCOUT_WAYPOINT_DISTANCE apart
          if(d.waypoints.length === 0 && !d.taskCompleted){
            const angle = Math.random() * Math.PI * 2;
            const distance = SCOUT_WAYPOINT_DISTANCE + Math.random() * 150;
            const wx = clamp(d.x + Math.cos(angle) * distance, 40, mapSize.w - 40);
            const wy = clamp(d.y + Math.sin(angle) * distance, 40, mapSize.h - 40);
            d.waypoints.push({ x: wx, y: wy, id: generateId() });
          }
          
          // Check if scouting duration completed
          const timeFlying = t - (d.launchTime || t);
          if(timeFlying > SCOUT_PATROL_DURATION && !d.taskCompleted){
            d.taskCompleted = true;
            d.waypoints = [];
            const foundCount = d.poiDiscoveryCount || 0;
            if(foundCount === 0){
              log(`${d.name} scouting complete - no objects found`);
              updateStatusPrompt('No interesting points found');
              // Show scout action buttons if this is the selected drone
              if(selected && selected.id === d.id && el.scoutActionButtons){
                el.scoutActionButtons.style.display = 'flex';
              }
            } else {
              log(`${d.name} scouting complete - ${foundCount} object(s) found`);
              updateStatusPrompt(`Scouting complete - ${foundCount} object(s) found`);
            }
            // Automatically return to base after scouting is complete
            d.status = 'returning';
            d.waypoints = [{ x: mapSize.w/2, y: mapSize.h/2, id: generateId() }];
            log(`${d.name} returning to base`);
          }
        }

        // Explorer: Check for nearby unscanned POIs and auto-track between them
        if(d.type === 'explorer'){
          // Check if near a POI to scan it
          let scannedSomething = false;
          // Process POIs in reverse order so we can safely remove items during iteration
          for(let i = pointsOfInterest.length - 1; i >= 0; i--){
            const poi = pointsOfInterest[i];
            if(!poi.scanned && !scannedSomething){
              const dx = poi.x - d.x, dy = poi.y - d.y;
              const dist = Math.hypot(dx,dy);
              if(dist < 15){
                // Mark scanned
                poi.scanned = true;
                poi.discoveredBy = d.name;

                // Remove any stale waypoints that were targeting this POI (prevents re-targeting and circling)
                removeWaypointsForPoi(poi.id);
                removeWaypointsNear(poi.x, poi.y, 18);
                
                // Check if explorer finds items (increased probability)
                const foundItems = Math.random() < EXPLORER_DISCOVERY_PROBABILITY;
                if(foundItems){
                  poi.items = generateItems(poi.type);
                  poi.name = `${poi.type.charAt(0).toUpperCase()}${poi.type.slice(1)} #${i+1}`;
                  const itemList = poi.items.map(it => it.name).join(', ');
                  log(`${d.name} scanned ${poi.name} - Found: ${itemList}`);
                  updateStatusPrompt(`${poi.name} scanned - items identified`);
                } else {
                  // Nothing found - remove the POI from the map
                  log(`${d.name} scanned ${poi.type} - Nothing found, removing marker`);
                  updateStatusPrompt(`${poi.type} scanned - empty location`);
                  // remove waypoints for this poi (just in case) then remove the poi
                  removeWaypointsForPoi(poi.id);
                  removeWaypointsNear(poi.x, poi.y, 18);
                  pointsOfInterest.splice(i, 1); // Remove empty POI
                }
                scannedSomething = true;
              }
            }
          }
          
          // Auto-navigate to next unscanned POI if no waypoints
          if(d.waypoints.length === 0 && d.status === 'flying'){
            const unscanned = pointsOfInterest.filter(p => !p.scanned);
            if(unscanned.length > 0){
              const target = unscanned[Math.floor(Math.random() * unscanned.length)];
              // store poiId in the waypoint so we can remove it if POI changes
              d.waypoints.push({ x: target.x, y: target.y, id: generateId(), poiId: target.id });
              log(`${d.name} heading to investigate ${target.type}`);
            } else if(!d.taskCompleted){
              // No more unscanned POIs - return to base
              d.taskCompleted = true;
              d.status = 'returning';
              d.waypoints = [{ x: mapSize.w/2, y: mapSize.h/2, id: generateId() }];
              log(`${d.name} completed scanning - returning to base`);
              updateStatusPrompt(`${d.name} completed scanning - returning to base`);
            }
          }
        }

        // Collector: Check for nearby scanned POIs with items
        if(d.type === 'collector'){
          for(let i = pointsOfInterest.length - 1; i >= 0; i--){
            const poi = pointsOfInterest[i];
            if(poi.scanned && poi.items && poi.items.length > 0){
              const dx = poi.x - d.x, dy = poi.y - d.y;
              const dist = Math.hypot(dx,dy);
              if(dist < 15){
                // Collect all items from this POI
                poi.items.forEach(item => {
                  const collectedItem = {
                    id: 'item-' + generateId(),
                    name: item.name,
                    mundane: item.mundane,
                    source: poi.name,
                    collectedBy: d.name,
                    timestamp: Date.now()
                  };
                  collectedItems.push(collectedItem);
                  
                  // Mundane items go directly to parts inventory
                  // Non-mundane items stay in collected list and will appear in research page's "Collected from Drones" section
                  if(item.mundane){
                    addToPartsInventory(item.name);
                  }
                  
                  log(`${d.name} collected ${item.name} from ${poi.name}`);
                });
                saveCollectedItems();
                updateStatusPrompt(`Items collected from ${poi.name}`);
                
                // Remove any waypoints targeting this POI to prevent other drones from looping at the same spot
                removeWaypointsForPoi(poi.id);
                removeWaypointsNear(poi.x, poi.y, 18);
                
                // Remove POI after collection
                pointsOfInterest.splice(i, 1);
                
                // Look for next target immediately
                const ready = pointsOfInterest.filter(p => p.scanned && p.items && p.items.length > 0);
                if(ready.length > 0 && d.status === 'flying'){
                  const target = ready[Math.floor(Math.random() * ready.length)];
                  // include poiId so future removals clear this waypoint
                  d.waypoints = [{ x: target.x, y: target.y, id: generateId(), poiId: target.id }];
                  log(`${d.name} heading to collect from ${target.name}`);
                } else if(!d.taskCompleted){
                  // No more items to collect - return to base
                  d.taskCompleted = true;
                  d.status = 'returning';
                  d.waypoints = [{ x: mapSize.w/2, y: mapSize.h/2, id: generateId() }];
                  log(`${d.name} collection complete - returning to base`);
                  updateStatusPrompt(`${d.name} collection complete - returning to base`);
                }
                break;
              }
            }
          }
        }

        if(d.waypoints && d.waypoints.length){
          const wp = d.waypoints[0];
          const dx = wp.x - d.x, dy = wp.y - d.y;
          const dist = Math.hypot(dx,dy) || 1;
          const base = d.type === 'scout' ? 1.6 : (d.type === 'defender' ? 1.2 : 1.0);
          const desiredV = 0.9 + base;
          const tx = (dx / dist) * desiredV;
          const ty = (dy / dist) * desiredV;
          d.targetVx = lerp(d.targetVx, tx, 0.07);
          d.targetVy = lerp(d.targetVy, ty, 0.07);
          
          // Increase detection radius to stop at center (within ship circle)
          const stopThreshold = d.status === 'returning' ? RETURN_STOP_THRESHOLD : DEFAULT_STOP_THRESHOLD;
          
          if(dist < stopThreshold){
            d.waypoints.shift();
            
            // If drone was returning and reached center, stop completely and dock
            if(d.status === 'returning' && d.waypoints.length === 0){
              d.status = 'docked';
              d.targetVx = 0;
              d.targetVy = 0;
              d.vx = 0;
              d.vy = 0;
              d.alt = 0;
              d.taskCompleted = false;
              d.isOrbiting = false; // Clear orbital flag
              updateStatusPrompt(`${d.name} docked at base`);
              log(`${d.name} docked at base`);
            }
            
            // Defender: Resume orbital pattern when finishing a waypoint in orbit mode
            if(d.type === 'defender' && d.isOrbiting && d.waypoints.length === 0 && d.status === 'flying'){
              const orbitRadius = Math.min(mapSize.w, mapSize.h) * 0.15;
              const orbitPoints = 8;
              for(let i = 0; i < orbitPoints; i++){
                const angle = (i / orbitPoints) * Math.PI * 2;
                d.waypoints.push({
                  x: mapSize.w/2 + Math.cos(angle) * orbitRadius,
                  y: mapSize.h/2 + Math.sin(angle) * orbitRadius,
                  id: generateId()
                });
              }
            }
            
            // Collector looks for scanned POIs with items
            if(d.type === 'collector' && d.waypoints.length === 0 && d.status === 'flying'){
              const ready = pointsOfInterest.filter(p => p.scanned && p.items && p.items.length > 0);
              if(ready.length > 0){
                const target = ready[Math.floor(Math.random() * ready.length)];
                d.waypoints.push({ x: target.x, y: target.y, id: generateId(), poiId: target.id });
                log(`${d.name} heading to collect from ${target.name}`);
              } else if(!d.taskCompleted){
                // No more items - return to base
                d.taskCompleted = true;
                d.status = 'returning';
                d.waypoints = [{ x: mapSize.w/2, y: mapSize.h/2, id: generateId() }];
                log(`${d.name} collection complete - returning to base`);
                updateStatusPrompt(`${d.name} collection complete - returning to base`);
              }
            }
          }
        } else {
          // Only slow down if not hovering (completed task)
          if(d.status === 'hovering'){
            d.targetVx = 0;
            d.targetVy = 0;
          } else {
            d.targetVx = lerp(d.targetVx, 0, 0.02);
            d.targetVy = lerp(d.targetVy, 0, 0.02);
          }
        }

        d.vx = lerp(d.vx, d.targetVx, 0.12);
        d.vy = lerp(d.vy, d.targetVy, 0.12);

        // Force stop if status is idle, docked, hovering, or landing (landed at base)
        if(d.status === 'idle' || d.status === 'docked' || d.status === 'landing' || d.status === 'hovering'){
          d.vx = 0;
          d.vy = 0;
          d.targetVx = 0;
          d.targetVy = 0;
        }

        d.x += d.vx * (dt/16);
        d.y += d.vy * (dt/16);
        d.x = clamp(d.x, 6, mapSize.w-6);
        d.y = clamp(d.y, 6, mapSize.h-6);

        // Battery management: discharge when moving, charge when docked/idle
        if(Math.hypot(d.vx,d.vy) > 0.1){
          // Drain battery during missions (increased from 0.002 to make it more noticeable)
          d.battery = Math.max(0, d.battery - 0.008 * (dt/16));
        } else if((d.status === 'docked' || d.status === 'idle') && d.battery < 100){
          // Charge battery when docked/idle (0.05% per frame step, roughly 3% per second at 60fps)
          d.battery = Math.min(100, d.battery + 0.05 * (dt/16));
        }

        pushTrail(d);
      });

      updateTrails(dt);
      renderMap();
      renderCamera();

      if(selected){
        // Determine status display with proper charging/docked logic
        let displayStatus = selected.status;
        if(selected.status === 'docked' || selected.status === 'idle'){
          if(selected.battery >= 100){
            displayStatus = 'idle';
          } else {
            displayStatus = 'charging';
          }
        } else if(selected.status === 'flying'){
          displayStatus = 'active';
        }
        
        el.sel_status.textContent = displayStatus;
        el.sel_batt.textContent = Math.round(selected.battery) + '%';
        el.sel_alt.textContent = Math.round(selected.alt) + ' m';
        el.sel_spd.textContent = (Math.hypot(selected.vx, selected.vy)).toFixed(1) + ' m/s';
      }

      requestAnimationFrame(step);
    }

    // Camera: simulate a basic live feed for the selected drone
    function renderCamera(){
      const c = camCtx;
      const cw = el.camCanvas.width, ch = el.camCanvas.height;
      c.clearRect(0,0,cw,ch);
      // background
      c.fillStyle = '#000';
      c.fillRect(0,0,cw,ch);

      // header
      c.fillStyle = 'rgba(255,255,255,0.9)';
      c.font = '12px system-ui';
      if(selected){
        c.fillText(`Camera: ${selected.name} (${selected.type})`, 8, 14);
        // simulated scene background
        c.fillStyle = '#071217';
        c.fillRect(6,22,cw-12,ch-36);

        // simulate a "drone cursor" using drone's position relative to map
        const px = clamp(Math.round((selected.x / Math.max(1,mapSize.w)) * (cw - 40)) + 20, 12, cw-12);
        const py = clamp(Math.round((selected.y / Math.max(1,mapSize.h)) * (ch - 40)) + 20, 12, ch-12);
        const color = selected.type === 'defender' ? '#ffd47a' : (selected.type === 'scout' ? '#7ad1ff' : (selected.type === 'collector' ? '#d47aff' : '#9be7c6'));
        c.fillStyle = color;
        c.beginPath(); c.arc(px, py, 8, 0, Math.PI*2); c.fill();

        // status overlay
        c.fillStyle = 'rgba(255,255,255,0.9)';
        c.font = '11px system-ui';
        c.fillText(`${selected.status} ‚Ä¢ ${Math.round(selected.battery)}%`, 8, ch-8);
      } else {
        c.fillStyle = '#444';
        c.font = '12px system-ui';
        c.fillText('No active camera feed', 8, ch/2);
      }
    }

    // Initial setup
    resizeMapCanvas();
    // spawn a few starter drones (re-added Defender so it shows in the list)
    addDrone('Scout-01','scout'); addDrone('Explorer-01','explorer'); addDrone('Collector-01','collector'); addDrone('Defender-01','defender');

    // Controls (basic)
    el.btnNewDrone.addEventListener('click', () => {
      const count = parseInt(el.customDroneNumber.value) || 1;
      const type = el.newDroneType.value;
      if(count > 1){
        spawnWave(count);
      } else {
        addDrone(null, type);
      }
    });
    el.btnToggleTrails.addEventListener('click', () => { trailsEnabled = !trailsEnabled; });
    el.btnRecallAll.addEventListener('click', () => { recallAllDrones(); });

    // Map click/select
    el.mapCanvas.addEventListener('click', (ev) => {
      const rect = el.mapCanvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      // check for drone clicked
      const clicked = drones.find(d => Math.hypot(d.x - x, d.y - y) < 12);
      if(clicked){
        selectDrone(clicked.id);
        return;
      }
      // shift+click to add waypoint to all drones
      if(ev.shiftKey){
        drones.forEach(d => d.waypoints.push({ x,y,id: generateId() }));
        log(`Global waypoint added at (${Math.round(x)},${Math.round(y)})`);
        return;
      }
      // otherwise add waypoint to selected drone
      addWaypointToSelected(x,y);
    });

    // List buttons (delegate)
    el.droneList.addEventListener('click', (ev) => {
      const btn = ev.target.closest('button[data-action]');
      if(!btn) return;
      const id = btn.dataset.id;
      if(btn.dataset.action === 'select') selectDrone(id);
      if(btn.dataset.action === 'launch') launchDrone(id);
      if(btn.dataset.action === 'recall') recallDrone(id);
    });

    // Start loop
    requestAnimationFrame(step);

  })();
  </script>
</body>
</html>
