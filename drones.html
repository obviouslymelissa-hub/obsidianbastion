<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Drone Control — Obsidian Bastion</title>
  <link rel="stylesheet" href="app.css">
  <style>
    /* Page-specific small layout helpers */
    .wrap { max-width:1200px; margin:24px auto; padding:0 18px; }
    .controls-row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    /* Wider left/right columns and larger center (makes the center "screen" bigger) */
    .grid { display:grid; grid-template-columns: 300px 1fr 300px; gap:16px; margin-top:16px; }
    .panel-card { background:var(--panel-bg, #071019); padding:14px; border-radius:8px; color:var(--text, #e6eef6); }
    .drone-list .tile { display:flex; justify-content:space-between; align-items:center; padding:10px; margin-bottom:8px; background:rgba(255,255,255,0.02); border-radius:6px; }
    .tile .meta { font-size:0.9rem; color:var(--muted); }
    /* map styles: remove fixed height to let JS manage a larger, responsive height */
    #mapCanvas { width:100%; height:64vh; background:linear-gradient(180deg,#061018, #07131a); border-radius:8px; display:block; touch-action:none; }
    .telemetry dl { display:grid; grid-template-columns: 1fr 1fr; gap:6px 18px; }
    .log { max-height:220px; overflow:auto; font-family:monospace; font-size:12px; background:rgba(0,0,0,0.12); padding:8px; border-radius:6px; color:var(--muted); }
    .btn.small { padding:6px 8px; font-size:13px; }
    #joystick { position:fixed; right:18px; bottom:18px; width:120px; height:120px; border-radius:50%; background:rgba(255,255,255,0.02); display:flex; align-items:center; justify-content:center; z-index:40; touch-action:none; }
    #knob { width:42px; height:42px; border-radius:50%; background:rgba(255,255,255,0.06); transition:transform 0.02s linear; }
    .mission-controls { display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap; }
    .camera-box { background:#000; height:140px; border-radius:6px; overflow:hidden; display:flex; align-items:center; justify-content:center; color:#999; }
    /* coordinate inputs */
    .coord-controls { margin-left:auto; display:flex; gap:6px; align-items:center; }
    .coord-controls input, .coord-controls select { padding:6px 8px; border-radius:6px; background:rgba(255,255,255,0.02); color:inherit; border:1px solid rgba(255,255,255,0.03); width:64px; }
    @media (max-width: 980px) {
      .grid { grid-template-columns: 1fr; }
      .coord-controls { margin-top:8px; width:100%; justify-content:flex-start; }
    }
  </style>
</head>
<body>
  <!-- Shared header (copy from other pages) -->
  <header class="site-header">
    <div class="wrap header-wrap">
      <div class="header-left">
        <img src="images/StrOpBoard.png" alt="Strategic Operations Board" style="height:44px">
        <div class="header-text" aria-label="Site title">
          <h1 style="margin:0">Obsidian Bastion</h1>
          <h2 style="margin:0;font-weight:400;font-size:13px;color:var(--muted)">Drone Control</h2>
        </div>
      </div>
      <div class="header-right">
        <a href="onboardcomputer.html" class="return-command-hub" aria-label="Return to Onboard Computer">← Return</a>
      </div>
    </div>
  </header>

  <div class="wrap">
    <div class="page-header" style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <h1>Drone Launch & Operations</h1>
        <div class="small">Virtual drone playground — launch, pilot, and plan missions.</div>
      </div>
      <div class="controls">
        <div class="controls-row">
          <div id="connectionStatus" class="pill" style="background:#2b2b2b;padding:8px 10px">Local Simulation</div>
          <button id="btnLaunchAll" class="btn">Launch All</button>
          <button id="btnRecallAll" class="btn">Recall All</button>
          <button id="btnAbortAll" class="btn danger">Abort</button>
          <label style="display:flex;align-items:center;gap:8px"><input id="autoPilot" type="checkbox"> Auto-Pilot</label>
        </div>
      </div>
    </div>

    <div class="grid" role="main" aria-label="Drone control grid">
      <!-- Left: Drone list & mission editor -->
      <aside class="panel-card drone-list" aria-label="Drone list">
        <h3 style="margin:0 0 10px 0">Fleet</h3>
        <div id="droneList" aria-live="polite"></div>

        <hr style="margin:12px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)">

        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button id="btnNewDrone" class="btn small">Create Drone</button>
          <button id="btnScanArea" class="btn small">Scan Area</button>
          <button id="btnShuffle" class="btn small">Randomize</button>
        </div>

        <hr style="margin:12px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)">

        <div>
          <h4 style="margin:6px 0">Mission Editor</h4>
          <div class="mission-controls">
            <button id="btnSaveMission" class="btn small">Save Mission</button>
            <button id="btnLoadMission" class="btn small">Load Mission</button>
            <button id="btnClearWaypoints" class="btn small">Clear Waypoints</button>
          </div>
          <div class="small" style="margin-top:8px">Click map to add waypoint for selected drone. Drag waypoints to adjust or enter coordinates.</div>
        </div>
      </aside>

      <!-- Center: Map / Tactical display -->
      <section class="panel-card" aria-label="Tactical map">
        <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap">
          <h3 style="margin:0 0 10px 0;flex:0 0 auto">Tactical Map</h3>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="btnCenter" class="btn small">Center on Fleet</button>
            <button id="btnShowPaths" class="btn small">Toggle Paths</button>
            <button id="btnToggleTrails" class="btn small">Toggle Trails</button>
          </div>

          <!-- Coordinate controls (placed in map header area) -->
          <div class="coord-controls" style="margin-left:auto">
            <input id="coordX" placeholder="X" title="X coordinate or percent" />
            <input id="coordY" placeholder="Y" title="Y coordinate or percent" />
            <select id="coordMode" title="Coordinate mode">
              <option value="px">px</option>
              <option value="%">%</option>
            </select>
            <button id="btnGotoCoords" class="btn small">Go To</button>
          </div>
        </div>

        <canvas id="mapCanvas" width="1000" height="720" role="application" aria-label="Drone positions and paths"></canvas>
        <div style="margin-top:10px;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <div class="small" id="mapHint" style="margin-left:auto">Click drone to view | Shift+Click to add waypoint globally</div>
        </div>
      </section>

      <!-- Right: Telemetry, camera & logs -->
      <aside class="panel-card telemetry" aria-label="Telemetry and logs">
        <h3 style="margin:0 0 10px 0">Telemetry</h3>
        <div id="selectedDroneName" style="font-weight:700">—</div>
        <dl style="margin-top:8px">
          <div style="display:flex;justify-content:space-between"><div class="meta">Status</div><div id="sel_status" class="meta">—</div></div>
          <div style="display:flex;justify-content:space-between"><div class="meta">Battery</div><div id="sel_batt" class="meta">—</div></div>
          <div style="display:flex;justify-content:space-between"><div class="meta">Altitude</div><div id="sel_alt" class="meta">—</div></div>
          <div style="display:flex;justify-content:space-between"><div class="meta">Speed</div><div id="sel_spd" class="meta">—</div></div>
        </dl>

        <hr style="margin:10px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)">

        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
          <button id="btnCmdLaunch" class="btn small" disabled>Launch</button>
          <button id="btnCmdLand" class="btn small" disabled>Land</button>
          <button id="btnCmdReturn" class="btn small" disabled>Return</button>
          <button id="btnCmdAbort" class="btn small danger" disabled>Abort</button>
        </div>

        <div style="margin-bottom:8px">
          <div class="small">Camera</div>
          <div class="camera-box" id="cameraBox"><canvas id="camCanvas" width="280" height="140" style="width:100%;height:100%"></canvas></div>
        </div>

        <div class="small" style="margin-bottom:6px">Activity Log</div>
        <div id="log" class="log" aria-live="polite">No activity</div>
      </aside>
    </div>
  </div>

  <div id="joystick" title="Joystick (touch/mouse)">
    <div id="knob"></div>
  </div>

  <footer style="text-align:center;color:var(--muted);padding:24px 0 40px;border-top:1px solid rgba(255,255,255,0.03);margin-top:18px;font-style:italic;">
    <div style="margin-bottom:12px">
      <a href="index.html" style="color:var(--accent);text-decoration:none;font-weight:600">Vessel Profile</a>
    </div>
    &copy; 2026 - Turning Imagination Into Galactic Frontiers.
  </footer>

  <script>
  (function(){
    /* Enhanced client-side drone playground (updated)
       - Larger responsive center screen
       - Coordinate input to send drones to exact PX or % positions
       - window.droneConsole.goToCoords(...) API
    */

    // Elements
    const el = {
      droneList: document.getElementById('droneList'),
      mapCanvas: document.getElementById('mapCanvas'),
      selectedName: document.getElementById('selectedDroneName'),
      sel_status: document.getElementById('sel_status'),
      sel_batt: document.getElementById('sel_batt'),
      sel_alt: document.getElementById('sel_alt'),
      sel_spd: document.getElementById('sel_spd'),
      log: document.getElementById('log'),
      btnLaunchAll: document.getElementById('btnLaunchAll'),
      btnRecallAll: document.getElementById('btnRecallAll'),
      btnAbortAll: document.getElementById('btnAbortAll'),
      btnNewDrone: document.getElementById('btnNewDrone'),
      btnCmdLaunch: document.getElementById('btnCmdLaunch'),
      btnCmdLand: document.getElementById('btnCmdLand'),
      btnCmdReturn: document.getElementById('btnCmdReturn'),
      btnCmdAbort: document.getElementById('btnCmdAbort'),
      btnCenter: document.getElementById('btnCenter'),
      btnShowPaths: document.getElementById('btnShowPaths'),
      btnToggleTrails: document.getElementById('btnToggleTrails'),
      btnSaveMission: document.getElementById('btnSaveMission'),
      btnLoadMission: document.getElementById('btnLoadMission'),
      btnClearWaypoints: document.getElementById('btnClearWaypoints'),
      btnShuffle: document.getElementById('btnShuffle'),
      camCanvas: document.getElementById('camCanvas'),
      joystick: document.getElementById('joystick'),
      knob: document.getElementById('knob'),
      coordX: document.getElementById('coordX'),
      coordY: document.getElementById('coordY'),
      coordMode: document.getElementById('coordMode'),
      btnGotoCoords: document.getElementById('btnGotoCoords')
    };

    const ctx = el.mapCanvas.getContext('2d');
    const camCtx = el.camCanvas.getContext('2d');

    // Simulation state
    let drones = []; // full model {id,name,x,y,px,py,vx,vy,alt,battery,status,path[],waypoints[]}
    let selected = null;
    let showPaths = true;
    let trailsEnabled = true;
    let trails = {}; // id -> array of {x,y,ttl}
    let mapSize = { w: el.mapCanvas.clientWidth, h: el.mapCanvas.clientHeight };

    function generateId(){ return 'd-'+Math.random().toString(36).slice(2,9); }
    function now(){ return Date.now(); }
    function log(msg){
      const ts = new Date().toLocaleTimeString();
      const line = `[${ts}] ${msg}`;
      const cur = el.log.textContent.trim();
      el.log.textContent = (cur === 'No activity' ? '' : cur + '\n') + line;
      el.log.scrollTop = el.log.scrollHeight;
      console.log(line);
    }
    function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    // Canvas resize for crispness & responsive size
    function resizeMapCanvas(){
      const DPR = window.devicePixelRatio || 1;
      const cw = el.mapCanvas.clientWidth;
      // use 64vh in CSS, so get clientHeight
      const ch = el.mapCanvas.clientHeight;
      el.mapCanvas.width = Math.max(320, Math.round(cw * DPR));
      el.mapCanvas.height = Math.max(240, Math.round(ch * DPR));
      // drawing transforms so our logical coords use client pixels
      ctx.setTransform(DPR,0,0,DPR,0,0);
      mapSize.w = cw;
      mapSize.h = ch;
      // recenter drones if newly created with default center
      drones.forEach(d => {
        d.x = clamp(d.x, 6, mapSize.w-6);
        d.y = clamp(d.y, 6, mapSize.h-6);
      });
    }
    window.addEventListener('resize', () => { resizeMapCanvas(); });

    // Create drone
    function addDrone(name){
      // ensure map size known
      if(!mapSize.w || !mapSize.h){ resizeMapCanvas(); }
      const d = {
        id: generateId(),
        name: name || ('Drone ' + (drones.length+1)),
        x: mapSize.w/2 + (Math.random()-0.5)*300,
        y: mapSize.h/2 + (Math.random()-0.5)*200,
        px: 0, py:0,
        vx: 0, vy: 0,
        targetVx: 0, targetVy: 0,
        alt: Math.floor(10 + Math.random()*90),
        battery: 70 + Math.floor(Math.random()*30),
        status: 'idle',
        path: [],
        waypoints: [],
        lastUpdate: now()
      };
      drones.push(d);
      trails[d.id] = [];
      log(`Created ${d.name}`);
      renderList();
      return d;
    }

    // List / UI
    function renderList(){
      el.droneList.innerHTML = '';
      drones.forEach(d => {
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.innerHTML = `
          <div>
            <div style="font-weight:700">${d.name}</div>
            <div class="meta">${d.status} • ${Math.round(d.battery)}% • alt ${Math.round(d.alt)}m</div>
          </div>
          <div style="display:flex;gap:6px;align-items:center">
            <button class="btn small" data-action="select" data-id="${d.id}">Select</button>
            <button class="btn small" data-action="launch" data-id="${d.id}">Launch</button>
          </div>
        `;
        el.droneList.appendChild(tile);
      });
    }

    function selectDrone(id){
      selected = drones.find(x => x.id === id) || null;
      if(selected){
        el.selectedName.textContent = `${selected.name} — ${selected.id}`;
        el.sel_status.textContent = selected.status;
        el.sel_batt.textContent = Math.round(selected.battery) + '%';
        el.sel_alt.textContent = Math.round(selected.alt) + ' m';
        el.sel_spd.textContent = (Math.hypot(selected.vx, selected.vy)).toFixed(1) + ' m/s';
        el.btnCmdLaunch.disabled = selected.status !== 'idle';
        el.btnCmdLand.disabled = selected.status !== 'flying';
        el.btnCmdReturn.disabled = selected.status === 'landing';
        el.btnCmdAbort.disabled = selected.status === 'idle';
      } else {
        el.selectedName.textContent = '—';
        el.sel_status.textContent = '—';
        el.sel_batt.textContent = '—';
        el.sel_alt.textContent = '—';
        el.sel_spd.textContent = '—';
        el.btnCmdLaunch.disabled = true;
        el.btnCmdLand.disabled = true;
        el.btnCmdReturn.disabled = true;
        el.btnCmdAbort.disabled = true;
      }
      renderMap();
    }

    // Commands
    function launchDrone(id){
      const d = drones.find(x => x.id === id);
      if(!d) return;
      d.status = 'flying';
      d.alt = 50;
      d.targetVx = (Math.random()-0.5) * 1.4;
      d.targetVy = (Math.random()-0.5) * 1.4;
      log(`Launched ${d.name}`);
      renderList();
    }
    function landDrone(id){
      const d = drones.find(x => x.id === id);
      if(!d) return;
      d.status = 'landing';
      d.targetVx = 0; d.targetVy = 0;
      log(`Landing ${d.name}`);
      setTimeout(() => {
        d.status = 'idle';
        d.alt = 0;
        renderList();
      }, 1600);
    }
    function recallDrone(id){
      const d = drones.find(x => x.id === id);
      if(!d) return;
      d.status = 'returning';
      d.waypoints = [{ x: mapSize.w/2, y: mapSize.h/2 }];
      log(`Recalling ${d.name}`);
    }
    function abortDrone(id){
      const d = drones.find(x => x.id === id);
      if(!d) return;
      d.status = 'idle';
      d.targetVx = 0; d.targetVy = 0; d.waypoints = [];
      log(`${d.name} aborted`);
      renderList();
    }

    // Waypoints & missions
    function addWaypointToSelected(x,y){
      if(!selected) { alert('Select a drone first'); return; }
      selected.waypoints.push({ x, y, id: generateId() });
      log(`Waypoint added to ${selected.name} (${Math.round(x)},${Math.round(y)})`);
    }

    function clearWaypoints(){
      if(!selected) return;
      selected.waypoints = [];
      log(`Waypoints cleared for ${selected.name}`);
    }

    function saveMission(){
      if(!selected) { alert('Select a drone to save its mission'); return; }
      const key = 'mission:' + selected.id;
      localStorage.setItem(key, JSON.stringify(selected.waypoints));
      log(`Saved mission for ${selected.name}`);
    }

    function loadMission(){
      if(!selected) { alert('Select a drone to load mission'); return; }
      const key = 'mission:' + selected.id;
      const raw = localStorage.getItem(key);
      if(!raw) { alert('No saved mission'); return; }
      try {
        selected.waypoints = JSON.parse(raw);
        log(`Loaded mission for ${selected.name}`);
      } catch(e){ alert('Failed to load mission'); }
    }

    // Programmatic: go-to-coords, percent mode optional
    function goToCoords(id, x, y, opts = { percent: false }){
      // if percent mode, x,y are 0..100
      const d = drones.find(z => z.id === id);
      if(!d) return;
      let targetX = x, targetY = y;
      if(opts.percent){
        targetX = (x/100) * mapSize.w;
        targetY = (y/100) * mapSize.h;
      }
      // clamp
      targetX = clamp(targetX, 6, mapSize.w-6);
      targetY = clamp(targetY, 6, mapSize.h-6);
      // add waypoint
      d.waypoints.push({ x: targetX, y: targetY, id: generateId() });
      d.status = 'flying';
      log(`Ordered ${d.name} to go to ${opts.percent ? `${x}% , ${y}%` : `${Math.round(targetX)},${Math.round(targetY)}`}`);
    }

    // Trails: append points as drone moves
    function pushTrail(d){
      const t = trails[d.id] || (trails[d.id]=[]);
      t.push({ x:d.x, y:d.y, ttl: 2000 + Math.random()*800 });
      if(t.length > 200) t.shift();
    }
    function updateTrails(dt){
      Object.keys(trails).forEach(id => {
        const arr = trails[id];
        for(let i = arr.length-1; i >= 0; --i){
          arr[i].ttl -= dt;
          if(arr[i].ttl <= 0) arr.splice(i,1);
        }
      });
    }

    // Map rendering
    function renderMap(){
      const c = ctx;
      c.clearRect(0,0,mapSize.w,mapSize.h);

      // background
      c.fillStyle = '#041217';
      c.fillRect(0,0,mapSize.w,mapSize.h);

      // trails
      if(trailsEnabled){
        Object.values(trails).forEach(arr => {
          for(let i=1;i<arr.length;i++){
            const a = arr[i-1], b = arr[i];
            c.beginPath();
            c.strokeStyle = `rgba(155,231,198,${0.08 + ((b.ttl||1000)/3000)})`;
            c.lineWidth = 2;
            c.moveTo(a.x,a.y); c.lineTo(b.x,b.y); c.stroke();
          }
        });
      }

      // paths and waypoints
      if(showPaths){
        drones.forEach(d => {
          if(d.waypoints && d.waypoints.length){
            c.beginPath();
            c.strokeStyle = 'rgba(255,180,130,0.18)';
            c.lineWidth = 1.2;
            c.moveTo(d.x,d.y);
            d.waypoints.forEach(w => c.lineTo(w.x,w.y));
            c.stroke();

            // draw waypoint markers
            d.waypoints.forEach(w => {
              c.beginPath();
              c.fillStyle = '#ffb482';
              c.arc(w.x, w.y, 6, 0, Math.PI*2);
              c.fill();
            });
          }
        });
      }

      // drones
      drones.forEach(d => {
        c.beginPath();
        const isSel = selected && selected.id === d.id;
        c.fillStyle = isSel ? '#ffd47a' : '#9be7c6';
        c.strokeStyle = isSel ? '#ffc66a' : '#0b1e22';
        c.lineWidth = isSel ? 2 : 1;
        c.arc(d.x, d.y, isSel ? 9 : 7, 0, Math.PI*2);
        c.fill();
        c.stroke();

        // label
        c.fillStyle = 'rgba(255,255,255,0.85)';
        c.font = '12px system-ui';
        c.fillText(d.name, d.x + 12, d.y + 5);
      });
    }

    // Simulation physics step
    let lastFrame = now();
    function step(){
      const t = now();
      const dt = t - lastFrame;
      lastFrame = t;

      drones.forEach(d => {
        // waypoint seeking
        if(d.waypoints && d.waypoints.length){
          const wp = d.waypoints[0];
          const dx = wp.x - d.x, dy = wp.y - d.y;
          const dist = Math.hypot(dx,dy) || 1;
          const desiredV = 0.9 + (d.status==='flying'?1.6:0);
          const tx = (dx / dist) * desiredV;
          const ty = (dy / dist) * desiredV;
          d.targetVx = lerp(d.targetVx, tx, 0.06);
          d.targetVy = lerp(d.targetVy, ty, 0.06);
          if(dist < 8){
            d.waypoints.shift();
            log(`${d.name} reached waypoint`);
          }
        } else {
          d.targetVx = lerp(d.targetVx, 0, 0.02);
          d.targetVy = lerp(d.targetVy, 0, 0.02);
        }

        d.vx = lerp(d.vx, d.targetVx, 0.12);
        d.vy = lerp(d.vy, d.targetVy, 0.12);

        d.x += d.vx * (dt/16);
        d.y += d.vy * (dt/16);
        d.x = clamp(d.x, 6, mapSize.w-6);
        d.y = clamp(d.y, 6, mapSize.h-6);

        if(d.status === 'flying' || d.status === 'returning'){
          d.battery = Math.max(0, d.battery - 0.002 * (dt/16));
        }

        pushTrail(d);
      });

      updateTrails(dt);
      renderMap();
      renderCamera();

      if(selected){
        el.sel_status.textContent = selected.status;
        el.sel_batt.textContent = Math.round(selected.battery) + '%';
        el.sel_alt.textContent = Math.round(selected.alt) + ' m';
        el.sel_spd.textContent = (Math.hypot(selected.vx, selected.vy)).toFixed(1) + ' m/s';
      }

      requestAnimationFrame(step);
    }

    // Simple simulated camera display
    function renderCamera(){
      const c = camCtx;
      const cw = el.camCanvas.width, ch = el.camCanvas.height;
      c.clearRect(0,0,cw,ch);
      c.fillStyle = '#000';
      c.fillRect(0,0,cw,ch);

      c.strokeStyle = '#17303a';
      c.lineWidth = 1;
      for(let x=0;x<cw;x+=28){ c.beginPath(); c.moveTo(x,0); c.lineTo(x,ch); c.stroke(); }
      for(let y=0;y<ch;y+=18){ c.beginPath(); c.moveTo(0,y); c.lineTo(cw,y); c.stroke(); }

      const focus = selected || drones[0];
      if(focus){
        c.fillStyle = '#2bbf9b';
        c.beginPath();
        const fx = ((focus.x / mapSize.w) * (cw*0.7)) + cw*0.15;
        const fy = ((focus.y / mapSize.h) * (ch*0.7)) + ch*0.15;
        c.arc(fx, fy, 8 + Math.sin(now()/300)*2, 0, Math.PI*2);
        c.fill();
        c.fillStyle = '#fff';
        c.font = '11px system-ui';
        c.fillText(focus.name, 8, ch-10);
      } else {
        c.fillStyle = '#666';
        c.fillText('No drone selected', 10, ch/2);
      }
    }

    // Map click selects or adds waypoint
    el.mapCanvas.addEventListener('click', (ev) => {
      const rect = el.mapCanvas.getBoundingClientRect();
      const x = (ev.clientX - rect.left);
      const y = (ev.clientY - rect.top);
      let nearest = null, dist = 9999;
      drones.forEach(d => {
        const dd = Math.hypot(d.x - x, d.y - y);
        if(dd < dist && dd < 24){ dist = dd; nearest = d; }
      });
      if(nearest) {
        selectDrone(nearest.id);
      } else if(ev.shiftKey) {
        drones.forEach(d => d.waypoints.push({ x,y,id:generateId() }));
        log(`Global waypoint added`);
      } else {
        addWaypointToSelected(x,y);
      }
    });

    // Coordinate Go To button
    el.btnGotoCoords.addEventListener('click', () => {
      if(!selected){ alert('Select a drone first'); return; }
      const rawX = el.coordX.value.trim();
      const rawY = el.coordY.value.trim();
      if(!rawX || !rawY){ alert('Enter both X and Y'); return; }
      const mode = el.coordMode.value;
      let x = parseFloat(rawX.replace('%',''));
      let y = parseFloat(rawY.replace('%',''));
      if(Number.isNaN(x) || Number.isNaN(y)){ alert('Invalid numbers'); return; }
      if(mode === '%'){ goToCoords(selected.id, x, y, { percent: true }); }
      else { // px
        // clamp px to current mapSize
        x = clamp(x, 6, mapSize.w-6);
        y = clamp(y, 6, mapSize.h-6);
        goToCoords(selected.id, x, y, { percent: false });
      }
    });

    // Joystick (pointer)
    (function initJoystick(){
      const js = el.joystick, knob = el.knob;
      let active = false, origin = { x:0, y:0 }, radius = 46;
      function updateOrigin(){
        const r = js.getBoundingClientRect();
        origin.x = r.left + r.width/2;
        origin.y = r.top + r.height/2;
      }
      updateOrigin();
      window.addEventListener('resize', updateOrigin);

      function onPointerMove(e){
        if(!active) return;
        const x = e.clientX - origin.x;
        const y = e.clientY - origin.y;
        const dist = Math.min(radius, Math.hypot(x,y));
        const ang = Math.atan2(y,x);
        const dx = Math.cos(ang) * dist;
        const dy = Math.sin(ang) * dist;
        knob.style.transform = `translate(${dx}px, ${dy}px)`;
        const normX = dx / radius;
        const normY = dy / radius;
        if(selected){
          selected.targetVx = normX * 2.2;
          selected.targetVy = normY * 2.2;
          if(selected.status === 'idle'){ selected.status = 'flying'; }
        }
      }
      function onPointerUp(){
        active = false;
        knob.style.transform = '';
        if(selected){
          selected.targetVx = 0; selected.targetVy = 0;
        }
        document.removeEventListener('pointermove', onPointerMove);
        document.removeEventListener('pointerup', onPointerUp);
      }
      js.addEventListener('pointerdown', (ev)=>{
        active = true; updateOrigin();
        document.addEventListener('pointermove', onPointerMove);
        document.addEventListener('pointerup', onPointerUp);
        ev.preventDefault();
      });
    })();

    // Keyboard controls
    window.addEventListener('keydown', (ev) => {
      if(!selected) return;
      const step = 0.6;
      let vx = 0, vy = 0;
      if(ev.key === ' ') { landDrone(selected.id); }
      if(ev.key.toLowerCase() === 'r') { recallDrone(selected.id); }
      if(ev.key === 'w' || ev.key === 'ArrowUp') vy = -step;
      if(ev.key === 's' || ev.key === 'ArrowDown') vy = step;
      if(ev.key === 'a' || ev.key === 'ArrowLeft') vx = -step;
      if(ev.key === 'd' || ev.key === 'ArrowRight') vx = step;
      if(vx || vy){ selected.targetVx = vx * 2.0; selected.targetVy = vy * 2.0; selected.status = 'flying'; }
    });

    // Gamepad polling
    setInterval(()=> {
      const gp = navigator.getGamepads ? navigator.getGamepads()[0] : null;
      if(!gp || !selected) return;
      const axX = gp.axes[0], axY = gp.axes[1];
      if(Math.abs(axX) > 0.12 || Math.abs(axY) > 0.12){
        selected.targetVx = axX * 2.2;
        selected.targetVy = axY * 2.2;
        selected.status = 'flying';
      } else {
        selected.targetVx = 0; selected.targetVy = 0;
      }
    }, 80);

    // UI bindings
    el.droneList.addEventListener('click', (ev) => {
      const btn = ev.target.closest('button');
      if(!btn) return;
      const id = btn.dataset.id;
      const act = btn.dataset.action;
      if(act === 'select') selectDrone(id);
      if(act === 'launch') launchDrone(id);
    });
    el.btnNewDrone.addEventListener('click', () => { addDrone(); renderList(); });
    el.btnLaunchAll.addEventListener('click', () => drones.forEach(d => d.status==='idle' && launchDrone(d.id)));
    el.btnRecallAll.addEventListener('click', () => drones.forEach(d => d.status==='flying' && recallDrone(d.id)));
    el.btnAbortAll.addEventListener('click', () => drones.forEach(d => abortDrone(d.id)));
    el.btnCmdLaunch.addEventListener('click', () => selected && launchDrone(selected.id));
    el.btnCmdLand.addEventListener('click', () => selected && landDrone(selected.id));
    el.btnCmdReturn.addEventListener('click', () => selected && recallDrone(selected.id));
    el.btnCmdAbort.addEventListener('click', () => selected && abortDrone(selected.id));
    el.btnCenter.addEventListener('click', () => {
      drones.forEach(d => { d.x = mapSize.w/2 + (Math.random()-0.5)*120; d.y = mapSize.h/2 + (Math.random()-0.5)*80; });
      log('Centered fleet');
    });
    el.btnShowPaths.addEventListener('click', ()=> { showPaths = !showPaths; el.btnShowPaths.textContent = showPaths ? 'Hide Paths' : 'Show Paths'; });
    el.btnToggleTrails.addEventListener('click', ()=> { trailsEnabled = !trailsEnabled; el.btnToggleTrails.textContent = trailsEnabled ? 'Disable Trails' : 'Enable Trails'; });
    el.btnSaveMission.addEventListener('click', saveMission);
    el.btnLoadMission.addEventListener('click', loadMission);
    el.btnClearWaypoints.addEventListener('click', clearWaypoints);
    el.btnShuffle.addEventListener('click', () => { drones.forEach(d => { d.x = Math.random()*mapSize.w; d.y = Math.random()*mapSize.h; }); log('Shuffled drones'); });

    // Dragging waypoints
    (function initWaypointDrag(){
      let dragging = null; // { drone, waypoint }
      function findWaypointAt(x,y){
        for(const d of drones){
          for(const w of d.waypoints){
            if(Math.hypot(w.x - x, w.y - y) < 9) return {d,w};
          }
        }
        return null;
      }
      el.mapCanvas.addEventListener('pointerdown', (ev) => {
        const rect = el.mapCanvas.getBoundingClientRect();
        const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
        const hit = findWaypointAt(x,y);
        if(hit){ dragging = { d: hit.d, w: hit.w }; ev.preventDefault(); }
      });
      window.addEventListener('pointermove', (ev) => {
        if(!dragging) return;
        const rect = el.mapCanvas.getBoundingClientRect();
        dragging.w.x = clamp(ev.clientX - rect.left, 8, mapSize.w-8);
        dragging.w.y = clamp(ev.clientY - rect.top, 8, mapSize.h-8);
      });
      window.addEventListener('pointerup', (ev) => { if(dragging){ log(`Waypoint moved for ${dragging.d.name}`); dragging = null; }});
    })();

    // Expose API
    window.droneConsole = {
      listDrones: () => drones.map(d => ({ id:d.id, name:d.name, status:d.status, battery: Math.round(d.battery) })),
      getStatus: (id) => drones.find(d => d.id === id) || null,
      launchDrone: (id) => launchDrone(id),
      landDrone: (id) => landDrone(id),
      recallDrone: (id) => recallDrone(id),
      createDrone: (name) => addDrone(name),
      saveMissionFor: (id) => { const d = drones.find(x=>x.id===id); if(d) localStorage.setItem('mission:'+id, JSON.stringify(d.waypoints)); },
      loadMissionFor: (id) => { const d = drones.find(x=>x.id===id); if(d){ const raw = localStorage.getItem('mission:'+id); if(raw) d.waypoints = JSON.parse(raw); } },
      goToCoords: (id, x, y, opts = { percent: false }) => goToCoords(id, x, y, opts)
    };

    // Initialization
    resizeMapCanvas();
    addDrone('Alpha-1'); addDrone('Beta-3'); addDrone('Scout-02');
    renderList();
    lastFrame = now();
    requestAnimationFrame(step);
    renderCamera();

    // Expose debug state
    window._drones = { state: () => drones.slice(), mapSize: () => Object.assign({}, mapSize) };

    // Small safety: when switching device DPR or resizing, keep canvas in sync
    setTimeout(() => { resizeMapCanvas(); }, 120);

  })();
  </script>

  /* Fun Mode for drones.html
   - overlay particle system
   - sound effects
   - collectible pickups that give short boosts
   - toggled with a button inserted into the page

   Drop into your site and include it after drones.html's main script.
*/
(function(){
  if(window._funModeInstalled) return;
  window._funModeInstalled = true;

  // Helpers
  const $ = (sel, root=document) => root.querySelector(sel);
  const mapCanvas = $('#mapCanvas');
  if(!mapCanvas) return;
  const mapWrap = mapCanvas.parentElement;
  const logEl = $('#log');
  const droneConsole = window.droneConsole;
  const dronesState = () => (window._drones && window._drones.state) ? window._drones.state() : [];
  const getDroneObj = (id) => (droneConsole && droneConsole.getStatus) ? droneConsole.getStatus(id) : null;

  // create overlay canvas
  const overlay = document.createElement('canvas');
  overlay.id = 'funOverlay';
  overlay.style.position = 'absolute';
  overlay.style.left = '0';
  overlay.style.top = '0';
  overlay.style.pointerEvents = 'none';
  overlay.style.zIndex = 999;
  overlay.width = mapCanvas.clientWidth;
  overlay.height = mapCanvas.clientHeight;
  mapWrap.style.position = mapWrap.style.position || 'relative';
  // position overlay to match mapCanvas
  mapWrap.appendChild(overlay);
  const octx = overlay.getContext('2d');

  function resizeOverlay(){
    const rect = mapCanvas.getBoundingClientRect();
    overlay.style.width = rect.width + 'px';
    overlay.style.height = rect.height + 'px';
    overlay.width = Math.max(320, Math.round(rect.width * (window.devicePixelRatio||1)));
    overlay.height = Math.max(240, Math.round(rect.height * (window.devicePixelRatio||1)));
    octx.setTransform(window.devicePixelRatio||1,0,0,window.devicePixelRatio||1,0,0);
  }
  window.addEventListener('resize', resizeOverlay);
  resizeOverlay();

  // simple audio assets (dataURIs or placeholder -> replace with your own files)
  const audio = {
    launch: new Audio('data:audio/ogg;base64,T2dnUwACAAAAAAAAAAB...'), // placeholder (silent)
    land: new Audio('data:audio/ogg;base64,T2dnUwACAAAAAAAAAAB...'),
    ping: new Audio('data:audio/ogg;base64,T2dnUwACAAAAAAAAAAB...'),
    pickup: new Audio('data:audio/ogg;base64,T2dnUwACAAAAAAAAAAB...')
  };
  // volume setup
  Object.values(audio).forEach(a => { try { a.volume = 0.35; } catch(e){} });

  // small particle system
  const particles = [];
  function spawnParticles(x,y, color='#ffd47a', count=18, spread=2){
    for(let i=0;i<count;i++){
      particles.push({
        x, y,
        vx: (Math.random()-0.5) * spread,
        vy: (Math.random()-0.9) * spread * 0.6,
        life: 600 + Math.random()*700,
        size: 2 + Math.random()*4,
        color
      });
    }
  }

  // confetti (bigger, rectangular)
  const confetti = [];
  function spawnConfetti(x,y,count=32){
    for(let i=0;i<count;i++){
      confetti.push({
        x,y,
        vx: (Math.random()-0.5) * 4,
        vy: -2 - Math.random()*4,
        life: 1000 + Math.random()*1200,
        w: 6 + Math.random()*8,
        h: 4 + Math.random()*6,
        color: ['#ff7a7a','#ffd47a','#9be7c6','#7ac6ff'][Math.floor(Math.random()*4)],
        rot: Math.random()*Math.PI*2,
        rotSpeed: (Math.random()-0.5)*0.2
      });
    }
  }

  // pickups
  const pickups = [];
  function spawnPickup(){
    const rect = mapCanvas.getBoundingClientRect();
    const x = 40 + Math.random()*(rect.width-80);
    const y = 40 + Math.random()*(rect.height-80);
    pickups.push({
      id: 'p-'+Math.random().toString(36).slice(2,8),
      x, y, radius: 12,
      type: Math.random() < 0.6 ? 'boost' : 'battery',
      ttl: 18000
    });
  }
  let pickupSpawnTimer = setInterval(spawnPickup, 11000);
  // start with a couple
  spawnPickup(); spawnPickup();

  // toggle UI button
  function insertFunButton(){
    const controlsRow = document.querySelector('.controls-row');
    if(!controlsRow) return;
    const btn = document.createElement('button');
    btn.id = 'btnFunMode';
    btn.className = 'btn small';
    btn.textContent = 'Enable Fun Mode';
    let enabled = false;
    btn.addEventListener('click', () => {
      enabled = !enabled;
      btn.textContent = enabled ? 'Fun Mode: ON' : 'Enable Fun Mode';
      overlay.style.display = enabled ? 'block' : 'none';
      if(enabled) {
        spawnConfetti(overlay.width/2, overlay.height/4, 24);
        play('ping');
      }
      // store setting
      localStorage.setItem('funModeEnabled',''+enabled);
    });
    // insert before other control buttons so it's visible
    controlsRow.insertBefore(btn, controlsRow.firstChild);
    // restore
    const saved = localStorage.getItem('funModeEnabled');
    if(saved === 'true') btn.click();
  }
  insertFunButton();

  // small wrapper to play a sound defensively
  function play(name){
    try{
      const a = audio[name];
      if(!a) return;
      const clone = a.cloneNode(true);
      clone.volume = a.volume;
      clone.play().catch(()=>{ /* muted or auto-play blocked */ });
    }catch(e){}
  }

  // wrap certain droneConsole functions to add effects
  if(window.droneConsole){
    // launch
    const origLaunch = window.droneConsole.launchDrone;
    if(origLaunch){
      window.droneConsole.launchDrone = function(id){
        const ret = origLaunch(id);
        // try play and spawn
        const d = getDroneObj(id);
        if(d) {
          const rect = mapCanvas.getBoundingClientRect();
          spawnParticles(d.x, d.y, '#7ac6ff', 26, 3);
          play('launch');
        }
        return ret;
      };
    }
    // land
    const origLand = window.droneConsole.landDrone;
    if(origLand){
      window.droneConsole.landDrone = function(id){
        const ret = origLand(id);
        const d = getDroneObj(id);
        if(d){
          spawnConfetti(d.x, d.y, 18);
          play('land');
        }
        return ret;
      };
    }
    // goToCoords: spawn a ping
    const origGoto = window.droneConsole.goToCoords;
    if(origGoto){
      window.droneConsole.goToCoords = function(id, x, y, opts){
        const ret = origGoto(id, x, y, opts);
        const d = getDroneObj(id);
        if(d){
          spawnParticles(d.x, d.y, '#ffd47a', 10, 2);
          play('ping');
        }
        return ret;
      };
    }
  }

  // pickup collision & effect
  function applyPickupToDrone(pick, drone){
    // get live object (not the copy)
    const d = getDroneObj(drone.id);
    if(!d) return;
    if(pick.type === 'boost'){
      // tiny impulse in direction the drone already moves (or random)
      d.vx += (Math.random()-0.5) * 3;
      d.vy += (Math.random()-0.5) * 3;
      // short visual marker
      d._funBoostUntil = Date.now() + 1800;
      if(logEl) {
        const ts = new Date().toLocaleTimeString();
        logEl.textContent = (logEl.textContent==='No activity' ? '' : logEl.textContent + '\n') + `[${ts}] ${d.name} grabbed SPEED BOOST!`;
        logEl.scrollTop = logEl.scrollHeight;
      }
      play('pickup');
      spawnConfetti(pick.x, pick.y, 22);
    } else if(pick.type === 'battery'){
      d.battery = Math.min(100, (d.battery || 10) + 18 + Math.random()*14);
      if(logEl) {
        const ts = new Date().toLocaleTimeString();
        logEl.textContent = (logEl.textContent==='No activity' ? '' : logEl.textContent + '\n') + `[${ts}] ${d.name} recharged battery`;
        logEl.scrollTop = logEl.scrollHeight;
      }
      play('pickup');
      spawnParticles(pick.x, pick.y, '#9be7c6', 18, 2);
    }
  }

  // short-lived "glow" indicator for boosted drones in overlay
  const glowCache = {};

  // animation loop for overlay elements
  let last = performance.now();
  function overlayLoop(ts){
    const dt = ts - last; last = ts;
    octx.clearRect(0,0,overlay.width,overlay.height);

    // update drones positions from public state
    const ds = dronesState();
    // draw pickups
    for(let i = pickups.length-1; i >= 0; --i){
      const p = pickups[i];
      p.ttl -= dt;
      if(p.ttl <= 0){ pickups.splice(i,1); continue; }
      // pulsing
      const pulse = 1 + Math.sin(Date.now()/250 + i)*0.12;
      octx.beginPath();
      octx.fillStyle = p.type === 'boost' ? 'rgba(255,186,130,0.95)' : 'rgba(155,231,198,0.95)';
      octx.arc(p.x, p.y, p.radius * pulse, 0, Math.PI*2);
      octx.fill();
      octx.strokeStyle = 'rgba(255,255,255,0.08)';
      octx.lineWidth = 1;
      octx.stroke();

      // collision detection with drones
      for(const dcopy of ds){
        const dLive = getDroneObj(dcopy.id);
        if(!dLive) continue;
        const dx = dLive.x - p.x;
        const dy = dLive.y - p.y;
        if(Math.hypot(dx,dy) < p.radius + 10){
          // collect
          applyPickupToDrone(p, dcopy);
          pickups.splice(i,1);
          break;
        }
      }
    }

    // particles
    for(let i = particles.length-1; i >= 0; --i){
      const p = particles[i];
      p.life -= dt;
      if(p.life <= 0){ particles.splice(i,1); continue; }
      p.x += p.vx * (dt/16);
      p.y += p.vy * (dt/16);
      p.vy += 0.06 * (dt/16); // gravity
      octx.beginPath();
      const alpha = Math.max(0, Math.min(1, p.life / 900));
      octx.fillStyle = `rgba(${hexToRgb(p.color)}, ${alpha})`;
      octx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      octx.fill();
    }

    // confetti
    for(let i = confetti.length-1; i >= 0; --i){
      const c = confetti[i];
      c.life -= dt;
      if(c.life <= 0){ confetti.splice(i,1); continue; }
      c.x += c.vx * (dt/16);
      c.y += c.vy * (dt/16);
      c.vy += 0.08 * (dt/16);
      c.rot += c.rotSpeed * (dt/16);
      octx.save();
      octx.translate(c.x, c.y);
      octx.rotate(c.rot);
      octx.fillStyle = c.color;
      octx.fillRect(-c.w/2, -c.h/2, c.w, c.h);
      octx.restore();
    }

    // draw vibe/glow on boosted drones
    ds.forEach(dcopy => {
      const dLive = getDroneObj(dcopy.id);
      if(!dLive) return;
      if(dLive._funBoostUntil && dLive._funBoostUntil > Date.now()){
        const alpha = Math.max(0, (dLive._funBoostUntil - Date.now())/1800);
        octx.beginPath();
        octx.fillStyle = `rgba(255,214,122,${alpha*0.95})`;
        octx.arc(dLive.x, dLive.y, 18, 0, Math.PI*2);
        octx.fill();
      }
    });

    // occasional cleanup: if overlay is hidden (Fun Mode off), skip drawing
    const funBtn = document.getElementById('btnFunMode');
    if(funBtn && funBtn.textContent.indexOf('ON') === -1){
      // hidden; still update pickups ttl but don't draw heavy things
    }

    requestAnimationFrame(overlayLoop);
  }

  function hexToRgb(hex){
    // supports #rrggbb or named color; if not hex, return '255,255,255'
    if(!hex) return '255,255,255';
    if(hex[0] !== '#') {
      // simple parse for some knowns
      const map = {
        '#ffd47a':'255,212,122','#9be7c6':'155,231,198','#7ac6ff':'122,198,255','#ff7a7a':'255,122,122'
      };
      return map[hex] || '255,255,255';
    }
    const r = parseInt(hex.substr(1,2),16);
    const g = parseInt(hex.substr(3,2),16);
    const b = parseInt(hex.substr(5,2),16);
    return `${r},${g},${b}`;
  }

  // spawn a pickup on demand (exposed)
  window.funMode = window.funMode || {};
  window.funMode.spawnPickup = spawnPickup;

  // start loop
  requestAnimationFrame(overlayLoop);

  // periodically spawn small particle bursts around random drones to keep things lively
  setInterval(()=>{
    const ds = dronesState();
    if(!ds.length) return;
    const pick = ds[Math.floor(Math.random()*ds.length)];
    if(!pick) return;
    spawnParticles(pick.x + (Math.random()-0.5)*18, pick.y + (Math.random()-0.5)*18, '#ffb482', 10, 2);
  }, 4200);

  // resize overlay whenever the map canvas changes size
  const ro = new ResizeObserver(resizeOverlay);
  ro.observe(mapCanvas);

})();
</body>
</html>
