<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Research Lab ‚Äî Obsidian Bastion</title>
  <link rel="stylesheet" href="app.css">
  <style>
    :root{
      --base-font-size:15px;
      --muted:#9aa6b2;
      --text-main:#e6eef6;
      --text-muted:#9aa6b2;
      --accent:#4fd1c5;
      --bg-panel:#151821;
    }

    /* Base typography and sizing (standardized) */
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      font-size: var(--base-font-size);
      color: var(--text-main);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
    h1 { font-size: 1.6rem; margin:0; }
    h2 { font-size: 0.85rem; margin:0; font-weight:400; color:var(--muted); }
    .page-header h1 { font-size: 1.6rem; }
    .panel-card h3 { font-size: 1.05rem; }

    /* Page-specific layout and styling */
    .wrap { max-width:1200px; margin:24px auto; padding:0 18px; }
    .page-header { margin-bottom:24px; }
    .hint { color:var(--muted); font-size:0.95rem; line-height:1.5; }
    
    /* Grid layout: form on left, list on right */
    .grid { display:grid; grid-template-columns: 380px 1fr; gap:20px; margin-top:20px; }
    @media (max-width: 980px) {
      .grid { grid-template-columns: 1fr; }
    }
    
    /* Panel card styling */
    .panel-card { 
      background:var(--bg-panel); 
      padding:20px; 
      border-radius:12px; 
      border:1px solid rgba(255,255,255,0.06);
      box-shadow: 0 6px 20px rgba(0,0,0,0.35);
    }
    .panel-card h3 { 
      margin:0 0 16px 0; 
      color:var(--accent); 
      font-weight:700; 
    }
    
    /* Form styling (standardized sizes) */
    .form-group { margin-bottom:16px; }
    .form-group label { 
      display:block; 
      margin-bottom:6px; 
      font-weight:600; 
      color:var(--text-main); 
      font-size:0.95rem; 
    }
    .form-group input,
    .form-group textarea,
    .form-group select {
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.08);
      background:rgba(255,255,255,0.02);
      color:var(--text-main);
      font-family:inherit;
      font-size:1rem; /* standardized input size */
      line-height:1.3;
    }
    .form-group textarea {
      min-height:100px;
      resize:vertical;
    }
    .form-group input:focus,
    .form-group textarea:focus,
    .form-group select:focus {
      outline:2px solid rgba(79,209,197,0.3);
      outline-offset:0;
      border-color:var(--accent);
    }
    
    /* Button styling */
    .btn {
      background:var(--accent);
      color:var(--bg-panel);
      padding:10px 16px;
      border-radius:8px;
      border:none;
      cursor:pointer;
      font-weight:700;
      font-size:0.95rem;
      transition:transform 0.12s ease, box-shadow 0.12s ease;
      box-shadow:0 4px 12px rgba(0,0,0,0.3);
    }
    .btn:hover {
      transform:translateY(-2px);
      box-shadow:0 6px 18px rgba(0,0,0,0.4);
    }
    .btn.secondary {
      background:rgba(255,255,255,0.06);
      color:var(--text-main);
    }
    .btn.danger {
      background:#e53e3e;
      color:#fff;
    }
    .btn.small {
      padding:6px 12px;
      font-size:0.85rem;
    }
    
    /* Research item card styling */
    .research-list {
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .research-item {
      background:rgba(255,255,255,0.02);
      padding:16px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.04);
      transition:background 0.2s ease;
      font-size:1rem; /* standardized */
    }
    .research-item:hover {
      background:rgba(255,255,255,0.04);
    }
    .research-header {
      display:flex;
      justify-content:space-between;
      align-items:start;
      margin-bottom:10px;
    }
    .research-title {
      font-size:1rem;
      font-weight:700;
      color:var(--text-main);
      margin:0 0 6px 0;
      display:flex;
      gap:8px;
      align-items:center;
    }
    .research-title .icon { font-size:1.1rem; opacity:0.95; }
    .research-meta {
      color:var(--muted);
      font-size:0.9rem;
      margin-top:4px;
    }
    .research-status {
      padding:4px 10px;
      border-radius:6px;
      font-size:0.78rem;
      font-weight:600;
      text-transform:uppercase;
      letter-spacing:0.5px;
    }
    .status-not-started { background:rgba(255,255,255,0.06); color:var(--muted); }
    .status-in-progress { background:rgba(251,191,36,0.15); color:#fbbf24; }
    .status-complete { background:rgba(79,209,197,0.15); color:var(--accent); }
    
    .research-description {
      color:var(--text-muted);
      font-size:0.95rem;
      line-height:1.45;
      margin-bottom:12px;
      white-space:pre-wrap;
    }
    .research-report {
      color:var(--text-main);
      background:rgba(0,0,0,0.06);
      padding:10px;
      border-radius:8px;
      font-size:0.9rem;
      margin-top:8px;
      white-space:pre-wrap;
    }
    .research-actions {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:8px;
    }
    
    /* Progress bar */
    .progress {
      width:100%;
      background:rgba(255,255,255,0.04);
      border-radius:8px;
      height:10px;
      overflow:hidden;
      margin-top:8px;
    }
    .progress .fill {
      height:100%;
      background:linear-gradient(90deg,var(--accent), #7ad1ff);
      width:0%;
      transition:width 200ms linear;
    }
    .time-remaining { margin-top:6px; }
    .time-remaining small { color:var(--muted); font-size:0.85rem; }

    /* Collected items panel */
    .collected-panel { margin-bottom:12px; padding-bottom:10px; border-bottom:1px solid rgba(255,255,255,0.03); }
    .collected-list { display:flex; flex-direction:column; gap:8px; margin-top:8px; }
    .collected-item { display:flex; justify-content:space-between; align-items:center; padding:8px; background:rgba(255,255,255,0.02); border-radius:8px; border:1px solid rgba(255,255,255,0.03); }
    .collected-item .meta { color:var(--muted); font-size:0.9rem; }
    
    /* Archive */
    .archive-panel { margin-top:20px; }
    .archive-list { display:grid; grid-template-columns: repeat(auto-fill,minmax(200px,1fr)); gap:12px; margin-top:12px; }
    .archive-item { background:rgba(255,255,255,0.02); padding:12px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); font-size:0.95rem; position:relative; }
    .archive-item .archive-title { display:flex; gap:8px; align-items:center; font-weight:700; }
    .archive-item .archive-icon { font-size:1.25rem; }
    .archive-item .archive-delete { position:absolute; right:8px; top:8px; padding:6px 8px; border-radius:6px; background:#b91c1c; color:#fff; border:none; cursor:pointer; font-weight:700; }

    /* Empty state */
    .empty-state {
      text-align:center;
      padding:60px 20px;
      color:var(--muted);
    }
    .empty-state svg {
      width:64px;
      height:64px;
      margin-bottom:16px;
      opacity:0.3;
    }
    .empty-state p {
      font-size:1.1rem;
      margin:0;
    }

    /* Modal (in-page confirmations and alerts) */
    .modal-overlay {
      position:fixed;
      inset:0;
      background:rgba(0,0,0,0.6);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:1200;
      opacity:0;
      pointer-events:none;
      transition:opacity 180ms ease;
    }
    .modal-overlay.open { opacity:1; pointer-events:auto; }
    .modal {
      width:clamp(320px, 40vw, 640px);
      background:var(--bg-panel);
      border-radius:10px;
      padding:18px;
      border:1px solid rgba(255,255,255,0.06);
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
      color:var(--text-main);
    }
    .modal h4 { margin:0 0 8px 0; font-size:1.05rem; color:var(--accent); }
    .modal .modal-body { color:var(--text-muted); font-size:0.95rem; white-space:pre-wrap; }
    .modal .modal-actions { display:flex; gap:8px; justify-content:flex-end; margin-top:14px; }
    .modal .btn.secondary { background:rgba(255,255,255,0.06); }
  </style>
</head>
<body>
  <!-- Shared header -->
  <header class="site-header">
    <div class="wrap header-wrap" style="display:flex;justify-content:space-between;align-items:center;">
      <div class="header-left">
        <img src="images/StrOpBoard.png" alt="Strategic Operations Board" style="height:44px">
        <div class="header-text" aria-label="Site title">
          <h1 style="margin:0">Obsidian Bastion</h1>
          <h2 style="margin:0;font-weight:400;font-size:13px;color:var(--muted)">Research Lab</h2>
        </div>
      </div>
      <div class="header-right">
        <a href="onboardcomputer.html" class="return-command-hub" aria-label="Return to Onboard Computer">‚Üê Return</a>
      </div>
    </div>
  </header>

  <div class="wrap">
    <div class="page-header">
      <h1>Research & Development Lab</h1>
      <div class="hint">
        Document and track items collected by drones. Add custom research projects, track progress, and store important notes about discovered artifacts and resources.
      </div>
    </div>

    <div class="grid" role="main">
      <!-- Left: Collected Items + Add/Edit Form -->
      <aside class="panel-card" aria-label="Research form">
        <!-- Collected items from drones -->
        <div id="collectedPanel" class="collected-panel" aria-label="Collected items from drones">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
            <h4 style="margin:0;color:var(--accent);font-weight:700">Collected from Drones</h4>
            <button id="btnDestroyAllSamples" class="btn danger small" style="display:none;">Destroy All Samples</button>
          </div>
          <div class="hint" style="margin-bottom:8px">Items collected by the drone deck will appear here. Click Research to move them to the Research Lab.</div>
          <div id="collectedList" class="collected-list">
            <!-- Filled by JS -->
          </div>
        </div>

        <h3 id="formTitle">Add New Research Item</h3>
        <form id="researchForm">
          <input type="hidden" id="editingId" value="">
          
          <div class="form-group">
            <label for="itemName">Item Name *</label>
            <input 
              type="text" 
              id="itemName" 
              placeholder="e.g., Ancient Artifact, Crystal Sample" 
              required
              maxlength="100"
            >
          </div>

          <div class="form-group">
            <label for="itemCategory">Item Type</label>
            <select id="itemCategory">
              <option value="Unknown">Unknown</option>
              <option value="Hardware">Hardware</option>
              <option value="Chemical">Chemical</option>
              <option value="Mineral">Mineral</option>
              <option value="Plant Life">Plant Life</option>
              <option value="Life Form">Life Form</option>
              <option value="Energy Source">Energy Source</option>
              <option value="Other">Other</option>
            </select>
          </div>

          <div style="display:flex;gap:10px;">
            <button type="submit" class="btn" id="submitBtn">Add Item</button>
            <button type="button" class="btn secondary" id="cancelBtn" style="display:none;">Cancel</button>
          </div>
        </form>
      </aside>

      <!-- Right: Research Items List -->
      <section class="panel-card" aria-label="Research items">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
          <h3 style="margin:0">Research Items <span id="itemCount" style="color:var(--muted);font-weight:400;font-size:0.9rem;">(0)</span></h3>
          <button id="btnMassDestroy" class="btn danger small" style="display:none;">Mass Destroy</button>
        </div>
        
        <div id="researchList" class="research-list">
          <!-- Items will be rendered here -->
        </div>

        <div id="emptyState" class="empty-state" style="display:none;">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2[...]
          </svg>
          <p>No research items yet</p>
          <p style="font-size:0.85rem;margin-top:8px;">Add your first research item using the form on the left</p>
        </div>

        <!-- Archive / Museum -->
        <div id="archivePanel" class="archive-panel">
          <h4 style="margin-top:18px;color:var(--accent);font-weight:700">Archived Artifacts</h4>
          <div class="hint" style="margin-bottom:8px">Items archived from research appear here as a museum of finds. Use the red X to remove archived entries.</div>
          <div id="archiveList" class="archive-list">
            <!-- Filled by JS -->
          </div>
        </div>
      </section>
    </div>
  </div>

  <!-- In-page modal used for confirms and alerts -->
  <div id="modalOverlay" class="modal-overlay" role="dialog" aria-hidden="true" aria-modal="true" style="display:none;">
    <div class="modal" role="document" aria-labelledby="modalTitle">
      <h4 id="modalTitle">Confirm</h4>
      <div class="modal-body" id="modalBody">Message</div>
      <div class="modal-actions" id="modalActions">
        <button class="btn secondary" id="modalCancel">Cancel</button>
        <button class="btn" id="modalConfirm">OK</button>
      </div>
    </div>
  </div>

  <footer style="text-align:center;color:var(--muted);padding:24px 0 40px;border-top:1px solid rgba(255,255,255,0.03);margin-top:32px;font-style:italic;">
    <div style="margin-bottom:12px">
      <a href="index.html" style="color:var(--accent);text-decoration:none;font-weight:600">Vessel Profile</a>
    </div>
    &copy; 2026 - Turning Imagination Into Galactic Frontiers.
  </footer>

  <script>
  (function(){
    // Storage keys
    const STORAGE_KEY = 'research:items:v1';
    const COLLECTED_KEY = 'drones:collected:v1';
    const ARCHIVE_KEY = 'research:archive:v1';
    const INVENTORY_KEY = 'ship.inventory.v1';
    
    // Elements
    const form = document.getElementById('researchForm');
    const formTitle = document.getElementById('formTitle');
    const itemName = document.getElementById('itemName');
    const itemCategory = document.getElementById('itemCategory');
    const editingId = document.getElementById('editingId');
    const submitBtn = document.getElementById('submitBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const researchList = document.getElementById('researchList');
    const emptyState = document.getElementById('emptyState');
    const itemCount = document.getElementById('itemCount');
    const btnMassDestroy = document.getElementById('btnMassDestroy');
    const btnDestroyAllSamples = document.getElementById('btnDestroyAllSamples');

    const collectedListEl = document.getElementById('collectedList');
    const archiveListEl = document.getElementById('archiveList');

    // Modal elements
    const modalOverlay = document.getElementById('modalOverlay');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');
    const modalConfirm = document.getElementById('modalConfirm');
    const modalCancel = document.getElementById('modalCancel');

    // State
    let items = loadItems();
    let collected = loadCollectedItems();
    let archive = loadArchiveItems();

    // Progress update timer
    let progressTimer = null;

    // Icon map for categories (used in archive & list decorations)
    const CATEGORY_ICONS = {
      'Hardware': 'üîß',
      'Chemical': '‚öóÔ∏è',
      'Mineral': 'ü™®',
      'Plant Life': 'üåø',
      'Life Form': 'üß¨',
      'Energy Source': '‚ö°',
      'Unknown': '‚ùì',
      'Other': 'üì¶'
    };

    // Master category list for random assignment (exclude 'Unknown')
    const CATEGORY_LIST = ['Hardware','Chemical','Mineral','Plant Life','Life Form','Energy Source','Other'];

    // Heuristic keyword map for inferring category from name
    const INFERENCE_KEYWORDS = [
      { category: 'Plant Life', keywords: ['plant', 'flora', 'spore', 'leaf', 'seed', 'fungus', 'fungi', 'moss', 'algae', 'herb'] },
      { category: 'Life Form', keywords: ['organism', 'lifeform', 'life form', 'creature', 'alien', 'worm', 'larva', 'specimen', 'beast'] },
      { category: 'Mineral', keywords: ['crystal', 'mineral', 'ore', 'rock', 'stone', 'gem', 'quartz', 'gold', 'nugget', 'diamond', 'platinum', 'titanium', 'iron', 'copper', 'uranium', 'dilithium', 'kyber'] },
      { category: 'Hardware', keywords: ['circuit', 'chip', 'antenna', 'module', 'computer', 'thruster', 'engine', 'plate', 'hull', 'sensor', 'processor', 'navigation', 'solar panel', 'pump', 'filter', 'analyzer', 'array', 'component'] },
      { category: 'Chemical', keywords: ['acid', 'chemical', 'compound', 'solvent', 'liquid', 'gas', 'substance', 'reagent'] },
      { category: 'Energy Source', keywords: ['battery', 'cell', 'reactor', 'core', 'capacitor', 'power', 'energy'] },
      { category: 'Other', keywords: ['probe', 'debris', 'junk', 'fragment', 'shard', 'artifact', 'wreckage', 'relic', 'technology'] }
    ];

    // Category-specific note pools (randomized)
    const NOTE_POOLS = {
      'Plant Life': [
        function(results){
          const medicinal = Math.random() < 0.35 && results.safe;
          const edible = !medicinal && Math.random() < (results.safe ? 0.25 : 0.05);
          const toxic = !edible && (Math.random() < (results.safe ? 0.05 : 0.6));
          results.flags = results.flags || {};
          results.flags.medicinal = !!medicinal;
          results.flags.edible = !!edible;
          results.flags.toxic = !!toxic;
          if(medicinal) return `Plant Notes: Contains compounds with potential medicinal properties. Recommend extraction and biochemical analysis for pharmacological use. Do NOT consume raw.`;
          if(edible) return `Plant Notes: Preliminary tests suggest parts are edible after cooking/processing. Recommend toxicity and allergen assays before consumption.`;
          if(toxic) return `Plant Notes: Toxin markers detected. Not safe for consumption. Use strict quarantine and protective handling.`;
          return `Plant Notes: Biological material detected; spores are present. Quarantine sample and run extended botanical assays before any handling.`;
        },
        function(results){
          const fermentable = Math.random() < 0.15 && results.safe;
          results.flags = results.flags || {};
          results.flags.fermentable = !!fermentable;
          if(fermentable) return `Plant Notes: Contains fermentable sugars ‚Äî potential food-starter or biochemical feedstock after lab processing.`;
          return `Plant Notes: Cellular structure fragile; preserve tissue samples for microscopy and DNA barcoding.`;
        }
      ],
      'Life Form': [
        function(results){
          const pathogen = Math.random() < 0.45 && !results.safe;
          results.flags = results.flags || {};
          results.flags.pathogen = !!pathogen;
          if(pathogen) return `Life Form Notes: Pathogenic signatures detected. Treat as biohazard; immediate containment required. Do NOT attempt contact without bio-safety protocols.`;
          const symbiont = !pathogen && Math.random() < 0.25;
          results.flags.symbiont = !!symbiont;
          if(symbiont) return `Life Form Notes: Signs of symbiotic behavior found. May interact with host organisms non-lethally ‚Äî further behavioral assays recommended.`;
          const edible = !pathogen && Math.random() < 0.08;
          results.flags.edible = !!edible;
          if(edible) return `Life Form Notes: Certain tissues appear nutritionally rich after proper preparation; however, ingestion is not recommended until toxicity and immunogenicity are ruled out.`;
          return `Life Form Notes: Biological signatures confirmed. Recommend containment, DNA sequencing, and consultation with senior xenobiology officers.`;
        },
        function(results){
          const aggressive = Math.random() < 0.18 && !results.safe;
          results.flags = results.flags || {};
          results.flags.aggressive = !!aggressive;
          if(aggressive) return `Life Form Notes: Aggressive behavior indicators observed. Keep at a safe distance and prioritize containment.`;
          return `Life Form Notes: No immediate threat observed; further study of behavior and diet recommended before any interaction.`;
        }
      ],
      'Hardware': [
        function(results){
          const reusable = Math.random() < 0.5;
          results.flags = results.flags || {};
          results.flags.reusable = !!reusable;
          if(reusable) return `Hardware Notes: Component appears structurally sound and potentially reusable with minor refurbishment. Run interface compatibility checks before integration.`;
          return `Hardware Notes: Corrosion or degradation detected; salvage may be possible for parts but full replacement recommended for safety-critical systems.`;
        },
        function(results){
          const exotic = Math.random() < 0.15;
          results.flags = results.flags || {};
          results.flags.exoticTech = !!exotic;
          if(exotic) return `Hardware Notes: Unexpected materials and manufacturing marks; contains non-standard architecture ‚Äî recommends detailed reverse-engineering.`;
          return `Hardware Notes: No power signature detected; internal diagnostics required to determine component integrity.`;
        }
      ],
      'Chemical': [
        function(results){
          const reactive = Math.random() < 0.4 && !results.safe;
          results.flags = results.flags || {};
          results.flags.reactive = !!reactive;
          if(reactive) return `Chemical Notes: Reactive components detected; avoid open-air exposure and consult chemistry protocols for neutralization.`;
          return `Chemical Notes: Low volatility detected; molecular composition unclear ‚Äî spectral chromatography recommended.`;
        },
        function(results){
          const energetic = Math.random() < 0.12;
          results.flags = results.flags || {};
          results.flags.energetic = !!energetic;
          if(energetic) return `Chemical Notes: Energetic compounds present. Store in blast-resistant containment and notify engineering.`;
          return `Chemical Notes: Sample stable under lab conditions; treat with standard chemical safety handling.`;
        }
      ],
      'Mineral': [
        function(results){
          const conductive = Math.random() < 0.35;
          results.flags = results.flags || {};
          results.flags.conductive = !!conductive;
          if(conductive) return `Mineral Notes: Crystalline structure shows high conductivity potential ‚Äî candidate for experimental energy applications.`;
          return `Mineral Notes: Dense crystalline lattice; may be valuable for materials research. Recommend non-destructive imaging and spectrometry.`;
        },
        function(results){
          const radioactive = Math.random() < 0.12 && !results.safe;
          results.flags = results.flags || {};
          results.flags.radioactive = !!radioactive;
          if(radioactive) return `Mineral Notes: Elevated radioactive isotopes detected beyond background levels; use shielding for transport and storage.`;
          return `Mineral Notes: No immediate hazard beyond trace radioactivity; proceed with geochemical assays.`;
        }
      ],
      'Energy Source': [
        function(results){
          const unstable = Math.random() < 0.25 && !results.safe;
          results.flags = results.flags || {};
          results.flags.stable = !unstable;
          if(unstable) return `Energy Notes: Instability detected in emission profile. DO NOT connect to ship systems; isolate and monitor remotely.`;
          return `Energy Notes: Stable energy cell candidate. With conditioning and diagnostics could be integrated as auxiliary power unit.`;
        },
        function(results){
          const highOutput = Math.random() < 0.15;
          results.flags = results.flags || {};
          results.flags.highOutput = !!highOutput;
          if(highOutput) return `Energy Notes: High output potential observed in controlled discharge tests; recommend engineering review before handling.`;
          return `Energy Notes: Low output but steady; useful for low-power instrumentation after certification.`;
        }
      ],
      'Other': [
        function(results){
          return `General Notes: Object does not match known categories closely. Collect more samples and run multi-disciplinary analysis.`;
        },
        function(results){
          return `General Notes: Origin unclear. Historical analysis and provenance tracking advised before any use.`;
        }
      ],
      'Unknown': [
        function(results){
          return `General Notes: Classification uncertain; preserve sample and route to specialized labs for deeper analysis.`;
        }
      ]
    };

    // Modal helper: shows built-in interface modal instead of window.confirm/alert
    function showModal({ title = 'Confirm', message = '', confirmText = 'OK', cancelText = 'Cancel', showCancel = true } = {}) {
      return new Promise(resolve => {
        modalTitle.textContent = title;
        modalBody.textContent = message;
        modalConfirm.textContent = confirmText;
        modalCancel.textContent = cancelText;
        modalCancel.style.display = showCancel ? '' : 'none';
        modalOverlay.style.display = 'flex';
        requestAnimationFrame(() => modalOverlay.classList.add('open'));
        modalOverlay.setAttribute('aria-hidden', 'false');

        function cleanup(result) {
          modalOverlay.classList.remove('open');
          modalOverlay.setAttribute('aria-hidden', 'true');
          setTimeout(() => { modalOverlay.style.display = 'none'; }, 180);
          modalConfirm.removeEventListener('click', onConfirm);
          modalCancel.removeEventListener('click', onCancel);
          document.removeEventListener('keydown', onKeyDown);
          resolve(result);
        }
        function onConfirm() { cleanup(true); }
        function onCancel() { cleanup(false); }
        function onKeyDown(e) {
          if(e.key === 'Escape') { cleanup(false); }
          if(e.key === 'Enter') { cleanup(true); }
        }

        modalConfirm.addEventListener('click', onConfirm);
        modalCancel.addEventListener('click', onCancel);
        document.addEventListener('keydown', onKeyDown);

        modalConfirm.focus();
      });
    }
    async function showConfirm(message, title = 'Confirm') {
      return await showModal({ title, message, confirmText: 'Confirm', cancelText: 'Cancel', showCancel: true });
    }
    async function showAlert(message, title = 'Notice') {
      await showModal({ title, message, confirmText: 'OK', cancelText: '', showCancel: false });
    }

    // Utilities: load/save with safe fallbacks
    function loadItems() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        const arr = raw ? JSON.parse(raw) : [];
        return Array.isArray(arr) ? arr : [];
      } catch (e) {
        console.error('Failed to load items:', e);
        return [];
      }
    }
    function saveItems() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(items));
      } catch (e) {
        console.error('Failed to save items:', e);
      }
    }
    function loadCollectedItems() {
      try {
        const raw = localStorage.getItem(COLLECTED_KEY);
        const arr = raw ? JSON.parse(raw) : [];
        return Array.isArray(arr) ? arr : [];
      } catch (e) {
        console.error('Failed to load collected items:', e);
        return [];
      }
    }
    function saveCollectedItems() {
      try {
        localStorage.setItem(COLLECTED_KEY, JSON.stringify(collected));
      } catch (e) {
        console.error('Failed to save collected items:', e);
      }
    }
    function loadArchiveItems() {
      try {
        const raw = localStorage.getItem(ARCHIVE_KEY);
        const arr = raw ? JSON.parse(raw) : [];
        return Array.isArray(arr) ? arr : [];
      } catch (e) {
        console.error('Failed to load archive:', e);
        return [];
      }
    }
    function saveArchiveItems() {
      try {
        localStorage.setItem(ARCHIVE_KEY, JSON.stringify(archive));
      } catch (e) {
        console.error('Failed to save archive:', e);
      }
    }
    function addToPartsInventory(itemName){
      try {
        const raw = localStorage.getItem(INVENTORY_KEY);
        const inventory = raw ? JSON.parse(raw) : {};
        
        const key = itemName.toLowerCase();
        if(inventory[key] == null) inventory[key] = 0;
        inventory[key] += 1;
        
        localStorage.setItem(INVENTORY_KEY, JSON.stringify(inventory));
        log(`Added ${itemName} to Parts Inventory`);
      } catch(e){
        console.error('Failed to add to inventory:', e);
      }
    }
    function generateId() {
      return 'r-' + Date.now() + '-' + Math.random().toString(36).slice(2, 9);
    }
    function log(msg){
      console.log('[Research Lab] ' + msg);
    }

    // Progress timer control
    function anyInProgress() {
      return items.some(i => i.status === 'in-progress');
    }
    function ensureProgressTimer() {
      if(progressTimer) return;
      progressTimer = setInterval(() => {
        if(!anyInProgress()){
          clearInterval(progressTimer);
          progressTimer = null;
        }
        render(); // update progress bars
      }, 250);
    }

    // Infer a category from a name using keyword heuristics (returns a category or 'Unknown')
    function inferCategoryFromName(name) {
      if (!name || typeof name !== 'string') return 'Unknown';
      const lower = name.toLowerCase();
      for (const entry of INFERENCE_KEYWORDS) {
        for (const kw of entry.keywords) {
          const re = new RegExp('\\b' + kw.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i');
          if (re.test(lower)) {
            return entry.category;
          }
        }
      }
      // fallback: try partial matches for common stems
      if (lower.includes('spore') || lower.includes('flora') || lower.includes('plant')) return 'Plant Life';
      if (lower.includes('alien') || lower.includes('organism') || lower.includes('larva')) return 'Life Form';
      if (lower.includes('crystal') || lower.includes('ore') || lower.includes('gem')) return 'Mineral';
      if (lower.includes('chip') || lower.includes('module') || lower.includes('sensor') || lower.includes('engine')) return 'Hardware';
      if (lower.includes('acid') || lower.includes('solvent') || lower.includes('chemical')) return 'Chemical';
      if (lower.includes('battery') || lower.includes('reactor') || lower.includes('power')) return 'Energy Source';
      return 'Unknown';
    }

    // Choose a random category from CATEGORY_LIST
    function chooseRandomCategory() {
      const i = Math.floor(Math.random() * CATEGORY_LIST.length);
      return CATEGORY_LIST[i];
    }

    // Attempt to infer categories for existing items that are Unknown or missing a category.
    // If inference fails, assign a random category.
    // Returns true if any changes were made.
    function inferUnknownCategoriesOnLoad() {
      let changed = false;
      for (const item of items) {
        if (!item.category || item.category === 'Unknown') {
          const inferred = inferCategoryFromName(item.name || '');
          if (inferred && inferred !== 'Unknown') {
            item.category = inferred;
            item._categoryAssigned = 'inferred';
            changed = true;
          } else {
            // assign random if cannot infer
            const rand = chooseRandomCategory();
            item.category = rand;
            item._categoryAssigned = 'random';
            changed = true;
          }
        }
      }
      if (changed) {
        saveItems();
      }
      return changed;
    }

    // Render collected items (top panel)
    function renderCollected() {
      collectedListEl.innerHTML = '';
      // Filter out items that have been moved to research (have movedToResearch timestamp)
      // These items remain in storage but are hidden from display to prevent duplicates
      const activeCollected = collected.filter(ci => !ci.movedToResearch);
      
      if(!activeCollected || activeCollected.length === 0) {
        const p = document.createElement('div');
        p.className = 'hint';
        p.textContent = 'No items collected yet.';
        collectedListEl.appendChild(p);
        if (btnDestroyAllSamples) btnDestroyAllSamples.style.display = 'none';
        return;
      }
      
      // Show mass destroy button when there are items
      if (btnDestroyAllSamples) btnDestroyAllSamples.style.display = 'inline-block';
      
      activeCollected.forEach(ci => {
        const row = document.createElement('div');
        row.className = 'collected-item';
        row.innerHTML = `
          <div>
            <div style="font-weight:700">${escapeHtml(ci.name || ci.itemName || 'Unknown')}</div>
            <div class="meta">${escapeHtml(ci.source || '')} ${ci.category ? '‚Ä¢ ' + escapeHtml(ci.category) : ''} ${ci.mundane === false ? '‚Ä¢ Interesting' : ''}</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <button class="btn small" onclick="researchCollectedItem('${ci.id}')">Research</button>
            <button class="btn small secondary" onclick="discardCollectedItem('${ci.id}')">Discard</button>
          </div>
        `;
        collectedListEl.appendChild(row);
      });
    }

    // Move collected item into research list and start automated research
    // Now shows a confirm/cancel modal before moving
    window.researchCollectedItem = async function(colId) {
      const idx = collected.findIndex(c => c.id === colId);
      if(idx === -1) return;
      const col = collected[idx];

      const confirm = await showConfirm(`Move "${col.name || col.itemName || 'Unknown'}" into the Research Lab for analysis?`, 'Move to Research Lab');
      if (!confirm) return;

      // Determine category: prefer provided category, otherwise infer from name; if inference fails, assign random
      let category = col.category || col.type || 'Unknown';
      if (!category || category === 'Unknown') {
        const inferred = inferCategoryFromName(col.name || col.itemName || '');
        if (inferred && inferred !== 'Unknown') {
          category = inferred;
        } else {
          category = chooseRandomCategory();
        }
      }

      const newItem = {
        id: generateId(),
        name: col.name || col.itemName || 'Unknown Artifact',
        category: category || 'Unknown',
        description: col.description || '',
        report: '',
        status: 'in-progress',
        createdAt: Date.now(),
        updatedAt: Date.now(),
        researchResults: null,
        researchStartedAt: null,
        researchDuration: null,
        researchTimeoutId: null
      };
      items.push(newItem);
      saveItems();

      // Mark item as moved instead of removing it
      // This prevents it from showing up again
      collected[idx].movedToResearch = Date.now();
      saveCollectedItems();
      renderCollected();
      render();

      // Start automated research process (simulate)
      simulateResearch(newItem.id);
    };

    // Discard collected item directly from collected panel (confirm)
    window.discardCollectedItem = async function(colId) {
      const idx = collected.findIndex(c => c.id === colId);
      if(idx === -1) return;
      const confirmed = await showConfirm('Discard this collected item? This cannot be undone.', 'Discard Collected Item');
      if(confirmed) {
        collected.splice(idx,1);
        saveCollectedItems();
        renderCollected();
      }
    };

    // Simulate research: after a delay, update item with results
    function simulateResearch(itemId) {
      const item = items.find(i => i.id === itemId);
      if(!item) return;
      const duration = 4000 + Math.floor(Math.random() * 6000);
      item.researchStartedAt = Date.now();
      item.researchDuration = duration;
      saveItems();
      item.researchTimeoutId = setTimeout(() => {
        item.researchTimeoutId = null;
        completeResearch(itemId);
      }, duration);
      saveItems();
      ensureProgressTimer();
    }

    // Helper to pick a random note from pool for a category and apply structured flags
    function pickTypeNoteForCategory(category, researchResults) {
      const pool = NOTE_POOLS[category] || NOTE_POOLS['Unknown'];
      if (!pool || pool.length === 0) return '';
      const idx = Math.floor(Math.random() * pool.length);
      try {
        return pool[idx](researchResults || {});
      } catch (e) {
        console.error('Note generation failed for', category, e);
        return '';
      }
    }

    // Complete research, attach results and randomized category-specific notes (no duplication)
    function completeResearch(itemId) {
      const item = items.find(i => i.id === itemId);
      if(!item) return;
      const safetyChance = 0.7;
      const isSafe = Math.random() < safetyChance;
      let radiation;
      if(isSafe) {
        radiation = (Math.random() * 0.5).toFixed(2) + ' mSv';
      } else {
        const r = 1 + Math.random() * 9;
        radiation = r.toFixed(2) + ' mSv';
      }
      const contamination = isSafe ? 'No significant contamination detected.' : 'Hazardous residues detected; handle with caution.';
      
      item.researchResults = {
        safe: isSafe,
        radiation,
        contamination,
        notes: '',
        completedAt: Date.now(),
        flags: {}
      };

      const typeNote = pickTypeNoteForCategory(item.category || 'Unknown', item.researchResults);
      item.researchResults.typeNotes = typeNote || '';

      item.status = 'complete';
      const resultTextParts = [
        '-- Research Results --',
        `Safe to use: ${isSafe ? 'Yes' : 'No'}`,
        `Radiation: ${radiation}`,
        `${contamination}`
      ];
      if (item.researchResults.typeNotes) {
        resultTextParts.push('', item.researchResults.typeNotes);
      }
      const resultText = resultTextParts.join('\n');

      if (!item.report || !item.report.includes(resultText)) {
        item.report = (item.report ? item.report + '\n\n' : '') + resultText;
      }
      item.updatedAt = Date.now();
      if(item.researchTimeoutId){
        clearTimeout(item.researchTimeoutId);
        item.researchTimeoutId = null;
      }
      saveItems();
      render();
    }

    // Archive artifact (confirm before moving)
    window.archiveItem = async function(id) {
      const idx = items.findIndex(i => i.id === id);
      if(idx === -1) return;
      const it = items[idx];
      const confirmed = await showConfirm(`Archive "${it.name}"? Move to museum archive.`, 'Archive Artifact');
      if (!confirmed) return;
      archive.push({
        id: it.id,
        name: it.name,
        category: it.category,
        description: it.description,
        report: it.report,
        researchResults: it.researchResults,
        archivedAt: Date.now()
      });
      saveArchiveItems();
      items.splice(idx,1);
      saveItems();
      render();
      renderArchive();
    };

    // Store as inventory (confirm before moving)
    window.storeAsInventory = async function(id) {
      const idx = items.findIndex(i => i.id === id);
      if(idx === -1) return;
      const it = items[idx];
      const confirmed = await showConfirm(`Store "${it.name}" in ship inventory?`, 'Store as Inventory');
      if (!confirmed) return;
      addToPartsInventory(it.name);
      items.splice(idx,1);
      saveItems();
      render();
      await showAlert(`${it.name} stored in ship inventory.`, 'Stored');
    };

    // Discard research item (confirm already present)
    window.discardItem = async function(id) {
      const idx = items.findIndex(i => i.id === id);
      if(idx === -1) return;
      const it = items[idx];
      const confirmed = await showConfirm(`Discard "${it.name}"? This will permanently remove it from records.`, 'Discard Item');
      if(confirmed) {
        if(it.researchTimeoutId){
          clearTimeout(it.researchTimeoutId);
          it.researchTimeoutId = null;
        }
        items.splice(idx,1);
        saveItems();
        render();
      }
    };

    // Remove item from archive (red X). Confirm before permanent delete.
    window.deleteArchiveItem = async function(id) {
      const idx = archive.findIndex(a => a.id === id);
      if(idx === -1) return;
      const a = archive[idx];
      const confirmed = await showConfirm(`Permanently destroy archived artifact "${a.name}"? This cannot be undone.`, 'Destroy Archived Artifact');
      if (!confirmed) return;
      archive.splice(idx,1);
      saveArchiveItems();
      renderArchive();
    };

    // Render archived items (with icons and red X delete button)
    function renderArchive() {
      archiveListEl.innerHTML = '';
      if(!archive || archive.length === 0) {
        const p = document.createElement('div');
        p.className = 'hint';
        p.textContent = 'No archived artifacts yet.';
        archiveListEl.appendChild(p);
        return;
      }
      archive.forEach(a => {
        const icon = CATEGORY_ICONS[a.category] || CATEGORY_ICONS['Unknown'];
        const node = document.createElement('div');
        node.className = 'archive-item';
        node.innerHTML = `
          <div class="archive-title"><span class="archive-icon">${escapeHtml(icon)}</span><span>${escapeHtml(a.name)}</span></div>
          <button class="archive-delete" title="Destroy archived artifact" onclick="deleteArchiveItem('${a.id}')">‚úï</button>
          <div class="meta" style="margin:8px 0;font-size:0.9rem">${a.category ? escapeHtml(a.category) + ' ‚Ä¢ ' : ''}${a.researchResults ? (a.researchResults.safe ? 'Safe' : 'Unsafe') + ' ‚Ä¢ ' + escapeHtml(a.researchResults.radiation) : ''}</div>
          <div style="font-size:0.85rem;color:var(--muted);white-space:pre-wrap">${escapeHtml(a.description || '')}${a.report ? '\n\n' + escapeHtml(a.report) : ''}</div>
        `;
        archiveListEl.appendChild(node);
      });
    }

    // Render all research items ‚Äî preserve array order
    function render() {
      researchList.innerHTML = '';
      
      if (items.length === 0) {
        researchList.style.display = 'none';
        emptyState.style.display = 'block';
        itemCount.textContent = '(0)';
        if (btnMassDestroy) btnMassDestroy.style.display = 'none';
      } else {
        researchList.style.display = 'flex';
        emptyState.style.display = 'none';
        itemCount.textContent = `(${items.length})`;
        if (btnMassDestroy) btnMassDestroy.style.display = items.length > 1 ? 'inline-block' : 'none';
      }
      
      items.forEach(item => {
        const card = document.createElement('div');
        card.className = 'research-item';
        
        const statusClass = `status-${item.status}`;
        const statusLabel = (item.status || 'not-started').split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        const icon = CATEGORY_ICONS[item.category] || CATEGORY_ICONS['Unknown'];

        // Build action buttons depending on status
        let actionsHtml = '';
        if(item.status === 'in-progress') {
          actionsHtml += `<button class="btn small secondary" disabled>Researching‚Ä¶</button>`;
          actionsHtml += `<button class="btn small secondary" onclick="cancelResearch('${item.id}')">Cancel</button>`;
        } else if(item.status === 'complete') {
          actionsHtml += `<button class="btn small" onclick="archiveItem('${item.id}')">Archive Artifact</button>`;
          actionsHtml += `<button class="btn small" onclick="storeAsInventory('${item.id}')">Store as Inventory</button>`;
          actionsHtml += `<button class="btn small danger" onclick="discardItem('${item.id}')">Discard</button>`;
        } else {
          actionsHtml += `<button class="btn small" onclick="startResearchItem('${item.id}')">Start Research</button>`;
          actionsHtml += `<button class="btn small secondary" onclick="editItem('${item.id}')">Edit</button>`;
          actionsHtml += `<button class="btn small danger" onclick="deleteItem('${item.id}')">Stop Research and Destroy All Samples</button>`;
        }

        // Progress UI for in-progress items
        let progressHtml = '';
        if(item.status === 'in-progress') {
          const now = Date.now();
          let percent = 0;
          let remaining = null;
          if(item.researchStartedAt && item.researchDuration){
            const elapsed = now - item.researchStartedAt;
            percent = Math.min(100, Math.round((elapsed / item.researchDuration) * 100));
            remaining = Math.max(0, Math.ceil((item.researchDuration - elapsed) / 1000));
          }
          progressHtml = `
            <div class="progress" aria-hidden="true"><div class="fill" style="width:${percent}%"></div></div>
            <div class="time-remaining"><small>${percent}%${remaining !== null ? ' ‚Ä¢ ' + remaining + 's remaining' : ''}</small></div>
          `;
        }

        // Compose description/report display
        let descHtml = '';
        if(item.description) {
          descHtml += `<div class="research-description">${escapeHtml(item.description)}</div>`;
        }
        if(item.report) {
          descHtml += `<div class="research-report">${escapeHtml(item.report)}</div>`;
        }

        card.innerHTML = `
          <div class="research-header">
            <div>
              <h4 class="research-title"><span class="icon">${escapeHtml(icon)}</span><span>${escapeHtml(item.name)}</span></h4>
              <div class="research-meta">${item.category ? escapeHtml(item.category) : 'Unknown'}${item._categoryAssigned ? ' ‚Ä¢ ' + escapeHtml(item._categoryAssigned) : ''}</div>
            </div>
            <div><div class="research-status ${statusClass}">${statusLabel}</div></div>
          </div>
          ${descHtml}
          ${progressHtml}
          <div class="research-actions">
            ${actionsHtml}
          </div>
        `;
        
        researchList.appendChild(card);
      });
    }

    // Start research manually on an item
    window.startResearchItem = function(id) {
      const it = items.find(i => i.id === id);
      if(!it) return;
      it.status = 'in-progress';
      it.updatedAt = Date.now();
      saveItems();
      render();
      simulateResearch(it.id);
    };

    // Cancel research (best-effort: clear timeout and mark not-started)
    window.cancelResearch = async function(id) {
      const it = items.find(i => i.id === id);
      if(!it) return;
      const confirmed = await showConfirm('Cancel current research? Item will be returned to Not Started.', 'Cancel Research');
      if(confirmed){
        if(it.researchTimeoutId){
          clearTimeout(it.researchTimeoutId);
          it.researchTimeoutId = null;
        }
        it.status = 'not-started';
        it.researchStartedAt = null;
        it.researchDuration = null;
        it.updatedAt = Date.now();
        saveItems();
        render();
      }
    };

    // Edit & Delete from original UI (exposed for use by inline onclicks)
    window.editItem = function(id) {
      const item = items.find(i => i.id === id);
      if (!item) return;
      
      editingId.value = item.id;
      itemName.value = item.name;
      itemCategory.value = item.category || 'Unknown';
      
      formTitle.textContent = 'Edit Research Item';
      submitBtn.textContent = 'Update Item';
      cancelBtn.style.display = 'inline-block';
      
      form.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      itemName.focus();
    };

    window.deleteItem = async function(id) {
      const item = items.find(i => i.id === id);
      if (!item) return;
      
      const confirmed = await showConfirm(
        `Stop research and destroy all samples for "${item.name}"? This cannot be undone.`, 
        'Stop Research and Destroy All Samples'
      );
      if (confirmed) {
        if(item.researchTimeoutId){
          clearTimeout(item.researchTimeoutId);
        }
        items = items.filter(i => i.id !== id);
        saveItems();
        render();
        
        if (editingId.value === id) {
          resetForm();
        }
      }
    };

    // Cancel editing
    cancelBtn.addEventListener('click', resetForm);

    // Reset form to add mode
    function resetForm() {
      form.reset();
      editingId.value = '';
      formTitle.textContent = 'Add New Research Item';
      submitBtn.textContent = 'Add Item';
      cancelBtn.style.display = 'none';
    }

    // Escape HTML to prevent XSS
    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    // Form submit ‚Äî add or update (infer category when Unknown, or assign random if inference fails)
    form.addEventListener('submit', (e) => {
      e.preventDefault();
      
      const id = editingId.value;
      const name = itemName.value.trim();
      let category = itemCategory.value || 'Unknown';

      if (!name) {
        itemName.focus();
        return;
      }
      
      if (!category || category === 'Unknown') {
        const inferred = inferCategoryFromName(name);
        if (inferred && inferred !== 'Unknown') {
          category = inferred;
        } else {
          category = chooseRandomCategory();
        }
      }

      if (id) {
        const item = items.find(i => i.id === id);
        if (item) {
          item.name = name;
          item.category = category;
          item._categoryAssigned = (inferCategoryFromName(name) === category) ? 'inferred' : 'manual';
          item.updatedAt = Date.now();
        }
      } else {
        const newItem = {
          id: generateId(),
          name,
          category,
          description: '',
          report: '',
          status: 'not-started',
          createdAt: Date.now(),
          updatedAt: Date.now(),
          researchResults: null,
          researchStartedAt: null,
          researchDuration: null,
          researchTimeoutId: null,
          _categoryAssigned: (inferCategoryFromName(name) === category) ? 'inferred' : 'manual'
        };
        items.push(newItem);
      }
      
      saveItems();
      render();
      resetForm();
    });

    // Mass destroy handler
    if (btnMassDestroy) {
      btnMassDestroy.addEventListener('click', async () => {
        if (items.length === 0) return;
        
        const confirmed = await showConfirm(
          `Destroy all ${items.length} research item(s)? This will permanently remove all items from research. This cannot be undone.`,
          'Mass Destroy Confirmation'
        );
        
        if (confirmed) {
          // Clear all timeouts
          items.forEach(item => {
            if (item.researchTimeoutId) {
              clearTimeout(item.researchTimeoutId);
            }
          });
          
          // Clear items array in-place to maintain references
          items.length = 0;
          saveItems();
          render();
          
          await showAlert(`All research items destroyed.`, 'Mass Destroy Complete');
        }
      });
    }

    // Destroy all samples from collected items
    if (btnDestroyAllSamples) {
      btnDestroyAllSamples.addEventListener('click', async () => {
        const activeCollected = collected.filter(ci => !ci.movedToResearch);
        if (activeCollected.length === 0) return;
        
        const confirmed = await showConfirm(
          `Destroy all ${activeCollected.length} collected sample${activeCollected.length === 1 ? '' : 's'}? This will permanently remove all items from the collected list. This cannot be undone.`,
          'Destroy All Samples'
        );
        
        if (confirmed) {
          // Remove only the active collected items (not those moved to research)
          // Keep items that have been moved to research to avoid data inconsistency
          const movedItems = collected.filter(ci => ci.movedToResearch);
          collected.length = 0;
          collected.push(...movedItems);
          saveCollectedItems();
          renderCollected();
          
          await showAlert(`All collected samples destroyed.`, 'Samples Destroyed');
        }
      });
    }

    // On load: infer categories for existing unknown items, render everything
    (function init() {
      inferUnknownCategoriesOnLoad();
      renderCollected();
      render();
      renderArchive();
      if (anyInProgress()) ensureProgressTimer();
    })();

    // Expose minimal API for console debugging
    window.researchLab = {
      items: () => items,
      collected: () => collected,
      archive: () => archive,
      addCollectedForTesting: (name, source, category='Unknown', mundane=false) => {
        const c = { id: 'c-' + Date.now() + '-' + Math.random().toString(36).slice(2,6), name, source, category, mundane };
        collected.push(c);
        saveCollectedItems();
        renderCollected();
      },
      clearCollected: async () => {
        const confirmed = await showConfirm('Clear all collected items?', 'Clear Collected Items');
        if(confirmed){
          collected = [];
          saveCollectedItems();
          renderCollected();
        }
      }
    };
  })();
  </script>
</body>
</html>
